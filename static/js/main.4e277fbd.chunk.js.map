{"version":3,"sources":["reducers/memoryReducer.ts","harmonic/index.ts","harmonic/src/assembler/parser/util.ts","store.ts","components/theme/theme.ts","components/Memory.tsx","components/Registers.tsx","components/Stack.tsx","components/ProgramTables.tsx","harmonic/src/assembler/parser/instructions/generic.ts","harmonic/src/assembler/parser/arc/index.ts","harmonic/src/assembler/parser/parserTypes.ts","harmonic/src/assembler/parser/common.ts","harmonic/src/assembler/parser/interpretAs.ts","harmonic/src/assembler/parser/expressions.ts","harmonic/src/assembler/parser/instructions/instructions.ts","harmonic/src/assembler/parser/data.ts","harmonic/src/assembler/parser/constant.ts","harmonic/src/assembler/parser/structure.ts","harmonic/src/assembler/parser/index.ts","harmonic/src/cpu/programs.ts","harmonic/src/assembler/index.ts","components/Editor.tsx","components/styles.ts","components/ProgramMeta.tsx","components/language.ts","components/toasts.ts","components/nav/Logo.tsx","components/nav/SpeedSlider.tsx","components/nav/Header.tsx","App.tsx","index.tsx","harmonic/src/cpu/instructions.ts","harmonic/src/cpu/registers.ts","harmonic/src/cpu/CPU.ts","harmonic/src/cpu/createMemory.ts"],"names":["vm","init","program","base","previousMemory","memory","createMemory","writableBytes","Uint8Array","buffer","set","cpu","CPU","i","length","initVM","ParserTypes","initialState","meta","halt","memoryReducer","createSlice","name","reducers","initMachine","state","action","payload","reset","step","cycle","setMeta","toString","resetHalt","actions","registersSelector","createSelector","getRegisterBank","registers","pcSelector","getRegister","pc","spSelector","sp","metaSelector","haltSelector","memorySelector","serializableMiddleware","createSerializableStateInvariantMiddleware","isSerializable","value","isDataView","constructor","DataView","isUint8Array","isCPU","isTypedArrayOrCPU","isPlain","store","configureStore","reducer","middleware","useAppDispatch","useDispatch","useAppSelector","useSelector","theme","extendTheme","config","initialColorMode","useSystemColorMode","getMemoryRow","n","Array","from","_","byte","address","getUint8","e","console","log","msg","map","padStart","id","MainMemory","ref","end","tableCaption","getBase","rows","Math","floor","useState","setBase","useEffect","pcElem","spElem","pcCell","document","getElementsByClassName","spCell","classList","add","remove","useImperativeHandle","setBaseWrapped","isNaN","columns","memoryRows","push","size","height","variant","colorScheme","marginBottom","row","idx","className","memoryTable","forwardRef","Registers","registerTable","Object","keys","label","style","color","isNumeric","Stack","ProgramTables","memoryRef","useRef","display","minHeight","defaultValue","fontWeight","maxLength","width","fontSize","padding","onChange","event","current","parseInt","target","mnemonic","type","last","arr","asType","mapJoin","parser","items","join","typifyBracketedExpression","expr","BRACKETED_EXPRESSION","asBracketed","element","isArray","updateParserState","result","index","isError","error","updateParserError","errorMsg","Parser","parserStateTransformer","this","parserState","targetString","strict","finalParsed","Error","slice","min","mutator","nextState","selector","parse","char","c","TypeError","charAt","sequenceOf","parsers","results","many","assertResult","testState","sepBy","seperatorParser","valueParser","matchState","seperatorState","possibly","RE_ALL","RE_NEW_LINE","regex","re","slicedTarget","regexMatch","match","letters","letter","digits","digit","whitespace","comment","chain","optionalWhitespace","optionalComment","str","s","startsWith","choice","between","leftParser","rightParser","contentParser","many1","sepBy1","contextual","generatorFn","generator","nextValue","undefined","next","done","lookAhead","lazy","parserThunk","fail","errorMessage","success","parserTypes","register","REGISTER","hexLiteral","HEX_LITERAL","variable","VARIABLE","ADDRESS","opPlus","OP_PLUS","opMinus","OP_MINUS","opMultiply","OP_MULTIPLY","binaryOperation","BINARY_OPERATION","bracketedExpression","squareBracketedExpression","SQUARE_BRACKETED_EXPRESSION","LABEL","instruction","INSTRUCTION","data","DATA","constant","CONSTANT","structure","STRUCTURE","interpretAs","INTERPRET_AS","upperOrLowerStr","Arc","toUpperCase","toLowerCase","peek","registerLabel","hexDigit","validLabelIdentifier","x","operator","optionalWhitespaceSurrounded","commaSeperated","structureName","symbol","property","expressionElement","bracketedExpr","states","stack","ELEMENT_OR_OPENING_BRACKET","flag","nextChar","OPEN_BRACKET","OPERATOR_OR_CLOSING_BRACKET","CLOSE_BRACKET","pop","squareBracketExpr","EXPECT_ELEMENT","EXPECT_OPERATOR","disambiguateOrderOfOperations","operationPriorities","candidateExpression","priority","Infinity","leftOpr","rightOpr","op","level","newExpression","a","b","arg","litReg","arg1","arg2","args","regLit","regReg","r1","r2","regMem","addr","litMem","lit","noArgs","singleReg","singleLit","MOV","InstructionMnemonic","ADD","SUB","MUL","AND","OR","XOR","LSL","LSR","INC","DEC","NOT","JEQ","JNE","JLT","JGT","JLE","JGE","PSH","POP","CAL","RET","HLT","mov","instructionType","memReg","regIndReg","litOffReg","sub","mul","and","or","xor","lsl","lsr","inc","dec","not","jeq","jne","jlt","jgt","jle","jge","psh","cal","ret","hlt","dataParser","Boolean","isExport","values","data8","data16","constantParser","keyValuePair","key","structureParser","members","assemblyParser","reg","reduce","regMap","regName","machineCode","parsedInstructions","labels","structures","getNodeValue","node","member","offset","encodeHexLitorMem","expressionNode","hexVal","highByte","lowByte","encodeReg","mappedReg","nameCollision","assemble","assemblyCode","parsedOutput","run","ast","filter","currentAddress","forEach","valueSizeInBytes","totalBytes","metaData","instructionsMeta","pointerIndex","isAccountedFor","opCode","I","includes","regLit8","encodeHexLit8","parsedValue","encodeData8","encodeData16","assembled","EditorType","Pre","styled","div","pre","Line","LineNo","span","LineContent","ProgramMeta","instructions","pcLine","exampleCode","argString","punctuation","renderThumb","props","backgroundColor","borderRadius","position","left","zIndex","marginTop","bg","borderColor","fontFamily","instructionBase","defaultProps","code","language","tokens","getLineProps","getTokenProps","autoHide","autoHideTimeout","autoHideDuration","renderThumbVertical","renderView","flexDirection","inset","overflow","marginRight","paddingBottom","line","lineProps","token","minWidth","maxWidth","Editor","dispatch","ASSEMBLY","editor","setEditor","editorRef","languageID","monaco","useMonaco","setLanguageID","keywords","keyword","regs","languages","setMonarchTokensProvider","defaultToken","typeKeywords","operators","symbols","escapes","hexdigits","tokenizer","root","cases","include","useHarmonic","saveAssembly","getValue","setEditorWrapped","setDisableAssemble","MACHINE_CODE","generateMachineCode","message","toast","dismiss","trim","replace","autoClose","closeOnClick","pauseOnHover","draggable","hideProgressBar","progress","toastError","loadBinary","binaryBuffer","split","onClick","disabled","onMount","options","Logo","bgGradient","bgClip","SpeedSlider","open","React","sliderValue","setSliderValue","showTooltip","setShowTooltip","max","v","onMouseEnter","onMouseLeave","placement","isOpen","mt","ml","hasArrow","CloseIcon","viewBox","xmlns","fill","d","MenuIcon","MenuToggle","toggle","md","MenuAButton","children","rest","to","cursor","MenuLinks","handleAssemble","handleLoadBinary","handleStep","handleRun","handleRunSpeed","disabledAssemble","running","useColorMode","colorMode","toggleColorMode","baseAddr","fresh","flexBasis","spacing","align","justify","direction","pt","_hover","transition","htmlFor","checked","rounded","NavBarContainer","as","wrap","w","mb","p","NavBar","setIsOpen","App","setRunning","disableAssemble","runSpeed","runIntervalId","clearInterval","wasRunning","speed","setInterval","newSpeed","ReactDOM","render","getElementById","InstructionTypes","Instruction","instructionSize","MOV_RS_RD","MOV_LIT_RD","LDR_MEM_RD","STR_RS_MEM","STR_LIT_MEM","LDR_REG_IND_REG","LDR_LIT_OFF_REG","ADD_RX_RY","ADD_LIT_REG","SUB_RX_RY","SUB_REG_LIT","SUB_LIT_REG","MUL_REG_REG","MUL_LIT_REG","AND_REG_REG","AND_REG_LIT","OR_REG_REG","OR_REG_LIT","XOR_REG_REG","XOR_REG_LIT","LSL_REG_REG","LSL_REG_LIT","LSR_REG_REG","LSR_REG_LIT","INC_REG","DEC_REG","JEQ_REG","JEQ_LIT","JNE_REG","JMP_NOT_EQ","JLT_REG","JLT_LIT","JGT_REG","JGT_LIT","JLE_REG","JLE_LIT","JGE_REG","JGE_LIT","PSH_RS","PSH_LIT","CAL_RS","CAL_LIT","getMeta","INT","RET_INT","interruptVectorAddress","setRegister","bank","print","nextNBytes","getUint16","setUint16","nextInstructionAddress","nextLiteralsAddress","literals","fetch","spAddress","spAddressPopped","framePointerAddress","stackFrameSize","reverse","numberArgs","interruptVectorIndex","handlerAddressPointer","handlerAddress","pushState","literal","fetch16","registerIdx","fetchRegIndex","registerSrc","registerDest","srcVal","memAddress","ptr","baseAddress","rx","ry","registerValueX","registerValueY","registerValue","register1Value","register2Value","invertedValue","branchAddress","popState","interruptID","handleInterrupt","execute","setImmediate","bytes","ab","ArrayBuffer"],"mappings":"+JAOIA,E,+FCISC,EAAO,WAA+E,IAA9EC,EAA6E,uDAAvD,KAAMC,EAAiD,uCAAnCC,EAAmC,uCACxFC,EAASC,YAAa,OACtBC,EAAgB,IAAIC,WAAWH,EAAOI,QACxCL,GAAgBG,EAAcG,IAAIN,GAMtC,IALA,IAAMO,EAAM,IAAIC,IAAIP,GAKXQ,EAAI,EAAGX,GAAWW,EAAIX,EAAQY,OAAQD,IAC3CN,EAAcJ,EAAOU,GAAKX,EAAQW,GAGtC,MAAO,CAAER,SAAQE,gBAAeI,QDhBvBI,EAAS,SAACb,GAA8E,IAAzDC,EAAwD,uDAAzC,EAAGC,EAAsC,uDAAT,KACvFJ,EAAKC,EAAKC,EAASC,EAAMC,IAY7BW,EAAO,IAAIP,WAAW,KACtB,IEnBKQ,EFmBCC,EAA4B,CAC9BZ,OAAQL,EAAGK,OACXM,IAAKX,EAAGW,IACRO,KAAM,KACNX,cAAeP,EAAGO,cAClBY,MAAM,GAGGC,EAAgBC,YAAY,CACrCC,KAAM,SACNL,eACAM,SAAU,CAENC,YAAa,SAACC,EAAOC,GACjB,MAAiCA,EAAOC,QAAhCzB,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,KAAMyB,EAAvB,EAAuBA,MAGvB,OAFAb,EAAO,IAAIP,WAAWN,GAAUC,EAAMyB,EAAQ,KAAMH,EAAMlB,eAEnD,2BACAkB,GACAzB,IAIX6B,KAAM,SAACJ,GACH,IAAMN,EAAOnB,EAAGW,IAAImB,QAGpB,OAAO,uCACAL,GACAzB,GAFP,IAGImB,KAAMA,IAAQ,KAItBY,QAAS,SAACN,EAAOC,GACb,MAA4BA,EAAOC,QAA5BT,EAAP,EAAOA,KAAMf,EAAb,EAAaA,KAAMyB,EAAnB,EAAmBA,MAEnB,OAAO,2BACAH,GADP,IAEIP,KAAMU,EAAK,eAAKzB,EAAK6B,SAAS,IAAnB,YAA6Bd,IAA7B,2BAA2CO,EAAMP,MAAjD,kBAAyDf,EAAK6B,SAAS,IAAvE,YAAiFd,QAIpGe,UAAW,SAACR,GACR,OAAO,2BACAA,GADP,IAEIN,MAAM,QAMf,EAAkDC,EAAcc,QAAxDL,EAAR,EAAQA,KAAML,EAAd,EAAcA,YAAaO,EAA3B,EAA2BA,QAASE,EAApC,EAAoCA,UAG9BE,EAAoBC,aAC7B,SAACX,GAAD,OAAsBA,EAAMpB,OAAOM,IAAI0B,qBACvC,SAACC,GACG,OAAOA,KAIFC,EAAaH,aACtB,SAACX,GAAD,OAAsBA,EAAMpB,OAAOM,IAAI6B,YAAY,SACnD,SAACC,GACG,OAAOA,KAIFC,EAAaN,aACtB,SAACX,GAAD,OAAsBA,EAAMpB,OAAOM,IAAI6B,YAAY,SACnD,SAACG,GACG,OAAOA,KAIFC,EAAeR,aACxB,SAACX,GAAD,OAAsBA,EAAMpB,OAAOa,QACnC,SAACA,GACG,OAAOA,KAIF2B,EAAeT,aACxB,SAACX,GAAD,OAAsBA,EAAMpB,OAAOc,QACnC,SAACA,GACG,OAAOA,KAIF2B,EAAiBV,aAC1B,SAACX,GAAD,OAAsBA,EAAMpB,OAAOA,UACnC,SAACA,GACG,OAAOA,KAIAe,IAAf,QGrGM2B,EAAyBC,YAA2C,CACxEC,eAFqB,SAACC,GAAD,OATG,SAACA,GACvB,IAAKA,GAA4B,kBAAVA,EAAuB,OAAO,EACrD,IAAMC,EAAcD,EAAME,cAAgBC,SACpCC,EAAgBJ,EAAME,cAAgB5C,WACtC+C,EAASL,EAAME,cAAgBxC,IACrC,OAAOuC,GAAcG,GAAgBC,EAIFC,CAAkBN,IAAUO,YAAQP,MAM9DQ,EAAQC,YAAe,CAChCC,QAAS,CACLvD,OAAQe,GAEZyC,WAAY,CAACd,KAQJe,EAAiB,kBAAMC,eACvBC,EAAkDC,I,mCC5BhDC,EADDC,YAAY,CAAEC,OALA,CACxBC,iBAAkB,OAClBC,oBAAoB,K,kDCuBlBC,EAAe,SAAClE,EAAgBmE,EAAWrE,GAsB7C,OArBmBsE,MAAMC,KAAK,CAAC5D,OAAQ0D,IAAI,SAACG,EAAG9D,GAC3C,IACI+D,EADEC,EAAU1E,EAAOU,EAEvB,IACI+D,EAAOvE,EAAOyE,SAASD,GACzB,MAAOE,GACLC,QAAQC,IAAIF,EAAEG,KACdN,EAlBQ,MAoBZ,MAAO,CAAEA,OAAMC,cAChBM,KAAI,YAAwB,IAArBP,EAAoB,EAApBA,KAAMC,EAAc,EAAdA,QAQZ,MAAO,CAAED,KANLC,GAvBQ,MAwBRD,EAAI,YAAQA,EAAK5C,SAAS,IAAIoD,SAAS,EAAG,KAAtC,eADJ,GAM0BC,GAFlB,eAAWR,QAezBS,EAAa,SAAC,EAAwCC,GAAS,IAA/CC,EAA8C,EAA9CA,IACZnF,GAD0D,EAAzCoF,aACRzB,EAAelB,IACxBL,EAAKuB,EAAezB,GACpBI,EAAKqB,EAAetB,GASpBgD,EAAU,WACZ,OAAIF,EACQA,EAAMG,GAGX,GAAAC,KAAKC,MAAMpD,EAAE,KAExB,EAAwBqD,mBAASJ,KAAjC,mBAAOvF,EAAP,KAAa4F,EAAb,KAGAC,qBAAU,WACND,EAAQL,OACT,CAACjD,IAoCJuD,qBAAU,WACN,IAGIC,EACAC,EAJEC,EAASC,SAASC,uBAAT,eAAwC5D,IACjD6D,EAASF,SAASC,uBAAT,eAAwC1D,IAgBvD,OAVIwD,EAAO,KACPF,EAASE,EAAO,IACTI,UAAUC,IAAI,cAErBF,EAAO,KACPJ,EAASI,EAAO,IACTC,UAAUC,IAAI,cAIlB,WAAO,IAAD,IACH,QAAN,EAAAP,SAAA,SAAQM,UAAUE,OAAO,cACnB,QAAN,EAAAP,SAAA,SAAQK,UAAUE,OAAO,kBAgBjC,OANAC,8BAAoBnB,GAAK,iBAAO,CAC5BoB,eAD4B,SACZzD,IANG,SAACA,GACpB0D,MAAM1D,GAAS6C,EAAQL,KAAaK,EAAQ7C,GAMxCyD,CAAezD,OAEnB,IApEgB,SAAC/C,EAAcwF,EAAckB,GAG7C,IAFA,IAAMC,EAAa,GAEVjG,EAAIV,EAAMU,EAAIV,EAAOwF,EAAOkB,GAAWhG,EAAI,MAAQA,GAAKgG,EAC7DC,EAAWC,KAAKxC,EAAalE,EAAQwG,EAAShG,IAGlD,OACI,eAAC,IAAD,CAAOmG,KAAK,KAAKC,OAAO,MAAMC,QAAQ,UAAUC,YAAY,UAAUC,aAAc,MAApF,UACI,cAAC,IAAD,UACI,cAAC,IAAD,UACI,cAAC,IAAD,0BAGR,cAAC,IAAD,UAEMN,EAAW3B,KAAI,SAACkC,EAAKC,GAAN,OACb,cADgE,CAC/D,IAAD,WACI,cAAC,IAAD,uBAAYnH,EAAOmH,EAAMT,GAAS7E,SAAS,IAAIoD,SAAS,EAAG,KAA3D,SACMiC,EAAIlC,KAAI,gBAAEP,EAAF,EAAEA,KAAMS,EAAR,EAAQA,GAAR,OACN,cAAC,IAAD,CAAIkC,UAAYlC,EAAhB,SAAuBT,kBAmDrD4C,CAAYrH,EA7FD,EACA,IAgGAsH,uBAAWnC,GC9HXoC,EA1BC,WACd,IAAMpF,EAAY0B,EAAe7B,GAG3BwF,EAAgBC,OAAOC,KAAKvF,GAAW6C,KAAI,SAAC2C,EAAOR,GAAR,OAC/C,eAAC,IAAD,WACE,cAAC,IAAD,CAAIS,MAAO,CAAEC,MAAkB,OAAVF,EAAkB,2BAAwC,OAAVA,EAAkB,2BAA6B,WAApH,SAAmIA,IACnI,cAAC,IAAD,UAAOxF,EAAUwF,OAFTR,MAMZ,OACE,eAAC,IAAD,CAAON,KAAK,KAAKC,OAAO,QAAQC,QAAQ,UAAUC,YAAY,UAA9D,UACE,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAAC,IAAD,uBACA,cAAC,IAAD,CAAIc,WAAS,EAAb,2BAGJ,cAAC,IAAD,UACIN,QCdGO,EALD,WACV,IAAMvF,EAAKqB,EAAetB,GAC1B,OAAO,cAAC,EAAD,CAAY8C,IAAK7C,EAAK,EAAG8C,aAAa,WCuClC0C,EAvCO,WAClB,IAAMC,EAAYC,mBAGlB,OACA,sBAAKd,UAAU,kBAAf,UACI,sBAAKA,UAAU,YAAf,UACI,cAAC,IAAD,wBACA,cAAC,EAAD,OAEJ,sBAAKA,UAAU,aAAf,UACI,sBAAKQ,MAAO,CAACO,QAAS,QAASC,UAAW,SAA1C,UACI,sBAAKhB,UAAU,cAAf,UACI,cAAC,IAAD,0BACA,cAAC,IAAD,CACIiB,aAAc,OACdR,MAAO,WACPS,WAAY,OACZC,UAAW,EACXC,MAAO,OACPC,SAAU,OACVC,QAAS,MACTC,SAAU,SAAAC,GACNX,EAAUY,SAAWZ,EAAUY,QAAQrC,eAAesC,SAASF,EAAMG,OAAOhG,MAAO,WAK/F,cAAC,EAAD,CAAYqC,IAAK6C,OAErB,sBAAKb,UAAU,QAAf,UACI,cAAC,IAAD,oBACA,cAAC,EAAD,c,4DNxCXvG,K,oBAAAA,E,0BAAAA,E,oBAAAA,E,kBAAAA,E,kBAAAA,E,oBAAAA,E,0BAAAA,E,oCAAAA,E,4CAAAA,E,0DAAAA,E,cAAAA,E,0BAAAA,E,YAAAA,E,oBAAAA,E,sBAAAA,E,6BAAAA,M,KAgCL,IO6GgBmI,GAA+BC,GPpGzCC,GAAO,SAACC,GAAD,OAAgBA,EAAIA,EAAIxI,OAAS,IAQxCyI,GAAS,SAACH,GAAD,OAAuB,SAAClG,GAAD,MAA8B,CAAEkG,OAAMlG,WAOtEsG,GAAU,SAAAC,GAAM,OAAIA,EAAOtE,KAAI,SAAAuE,GAAK,OAAIA,EAAMC,KAAK,QAOnDC,GAA4B,SAA5BA,EAA6BC,GAE/B,OADoBN,GAAOvI,EAAY8I,qBAChCC,CAAYF,EAAK1E,KAAI,SAAA6E,GACxB,OAAIvF,MAAMwF,QAAQD,GACPJ,EAA0BI,GAE9BA,OQpDTE,GAAoB,SAAIzI,EAA4B0I,EAAWC,GAA3C,OACtBA,EAAK,2BAAQ3I,GAAR,IAAe2I,QAAOD,SAAQE,SAAS,EAAOC,MAAO,OAArD,2BAAmE7I,GAAnE,IAA0E0I,SAASE,SAAS,EAAOC,MAAO,QAS7GC,GAAoB,SAAO9I,EAA4B+I,GAAnC,kCACnB/I,GADmB,IAEtB4I,SAAS,EACTF,OAAQ,KACRG,MAAOE,K,0CAOLC,G,WASF,WAAYC,GAAuD,+EAC/D,aAAAC,KAAA,QAA+BD,E,0CAQnC,SAAME,GACF,OAAO,aAAAD,KAAP,QAAoCC,K,iBAQxC,SAAIC,GAAkE,IAA5CC,IAA2C,yDAC3D7J,EAAe,CACjB4J,eACAT,MAAO,EACPD,OAAQ,KACRE,SAAS,EACTC,MAAO,MAGLS,EAAW,aAAGJ,KAAH,QAAgC1J,GACjD,GAAI6J,GAAUC,EAAYX,OAASW,EAAYF,aAAa/J,OACpD,MAAM,IAAIkK,MAAM,8BAAuBD,EAAYX,MAAnC,gBACTW,EAAYF,aAAaI,MAAMF,EAAYX,MAAOxE,KAAKsF,IAAIH,EAAYX,MAAQ,GAAIW,EAAYF,aAAa/J,SADnG,SAGxB,OAAOiK,I,iBAWX,SAAOI,GAAuC,IAAD,OAEzC,OAAO,IAAIV,GAAO,SAAAG,GAEd,IAAMQ,EAAS,aAAG,EAAH,QAAgCR,GAG/C,OAAIQ,EAAUf,QAAgBe,EAEvBlB,GAAqBkB,EAAWD,EAAQC,EAAUjB,c,mBAUjE,SAAMkB,GAAiD,IAAD,OAClD,OAAO,IAAIZ,GAAO,SAAAG,GACd,IAAMQ,EAAS,aAAG,EAAH,QAAgCR,GAG/C,OAAIQ,EAAUf,QAAgBe,EAEXC,EAASD,EAAUjB,QACpBmB,MAAMF,U,KAoC9BG,GAAO,SAACC,GACV,IAAKA,GAAkB,IAAbA,EAAE1K,OACV,MAAM,IAAI2K,UAAJ,+DACoDD,IAI5D,OAAO,IAAIf,IAAO,SAAAG,GACd,GAAIA,EAAYP,QAAS,OAAOO,EAEhC,IAAQC,EAAwBD,EAAxBC,aAAcT,EAAUQ,EAAVR,MAEtB,GAA4B,IAAxBS,EAAa/J,OACb,OAAOyJ,GACHK,EADoB,+BAEIR,EAFJ,mCAEoCoB,EAFpC,6BAM5B,IAAMD,EAAOV,EAAaa,OAAOtB,GACjC,OAAOmB,IAASC,EACZtB,GAAkBU,EAAaY,EAAGpB,EAAQ,GAE1CG,GACIK,EADa,+BAEWR,EAFX,mCAE2CoB,EAF3C,mBAEuDD,EAFvD,UAevBI,GAAa,SAACC,GAAD,OAA4B,IAAInB,IAAO,SAACG,GACvD,GAAIA,EAAYP,QAAW,OAAOO,EAElC,IAH2F,EAGrFiB,EAAU,GACZT,EAAYR,EAJ2E,cAS3EgB,GAT2E,IAS3F,2BAAyB,CAGrB,IAFAR,EADqB,QACPE,MAAMF,IAENf,QAAW,OAAOe,EAChCS,EAAQ9E,KAAKqE,EAAUjB,SAbgE,8BAgB3F,OAAOD,GAAkBkB,EAAWS,OAgClCC,GAAO,SAAIrC,EAAmBsC,GAAvB,OAAkD,IAAItB,IAAO,SAACG,GACvE,GAAIA,EAAYP,QAAW,OAAOO,EAOlC,IALA,IAAMiB,EAAU,GACZT,EAAkCR,IAIzB,CACT,IAAMoB,EAAYvC,EAAO6B,MAAMF,GAE/B,GAAKY,EAAU3B,QAIX,MAHAwB,EAAQ9E,KAAKiF,EAAU7B,QACvBiB,EAAYY,EAOpB,OAAID,GAAmC,IAAnBF,EAAQ/K,OACjByJ,GAAkBa,EAAD,iEAAsEA,EAAUhB,MAAhF,MAGrBF,GAAkBkB,EAAWS,OAUlCI,GAAQ,SAAOC,EAA4BH,GAAnC,OAA8D,SAACI,GAAD,OAA4B,IAAI1B,IAAO,SAACG,GAIhH,IAHA,IAAMiB,EAAU,GACZT,EAAsCR,IAE7B,CACT,IAAMwB,EAAaD,EAAYb,MAAMF,GACrC,GAAIgB,EAAW/B,QAAW,MAE1BwB,EAAQ9E,KAAKqF,EAAWjC,QACxBiB,EAAYgB,EAEZ,IAAMC,EAAiBH,EAAgBZ,MAAMF,GAC7C,GAAIiB,EAAehC,QAAW,MAC9Be,EAAYiB,EAIhB,OAAIN,GAAmC,IAAnBF,EAAQ/K,OACjByJ,GAAkBa,EAAD,kEAAuEA,EAAUhB,MAAjF,MAGrBF,GAAkBkB,EAAWS,QAiHlCS,GAAW,SAAI7C,GAAJ,OAAqC,IAAIgB,IAAO,SAAAG,GAC7D,GAAIA,EAAYP,QAAW,OAAOO,EAElC,IAAMQ,EAAY3B,EAAO6B,MAAMV,GAC/B,OAAOQ,EAAUf,QAAWH,GAAkBU,EAAa,MAASQ,MAyBlEmB,GAAS,YACTC,GAAc,QAOdC,GAAQ,SAACC,GAAD,OAAgB,IAAIjC,IAAO,SAACG,GACtC,IACIC,EAGAD,EAHAC,aACAT,EAEAQ,EAFAR,MAIJ,GAFIQ,EADAP,QAGS,OAAOO,EAEpB,IAAM+B,EAAe9B,EAAaI,MAAMb,GACxC,GAA4B,IAAxBuC,EAAa7L,OACb,OAAOyJ,GAAkBK,EAAD,uCAI5B,IAAMgC,EAAaD,EAAaE,MAAMH,GAGtC,OAAIE,GAAuC,IAAzBA,EAAW,GAAG9L,OACrBoJ,GAAkBU,EAAagC,EAAW,GAAIxC,EAAQwC,EAAW,GAAG9L,QAGxEyJ,GAAkBK,EAAD,+CAAsDR,EAAtD,UAItB0C,GAAUL,GAvCG,cAwCbM,GAASN,GAvCG,YAwCZO,GAASP,GAvCG,WAwCZQ,GAAQR,GAvCG,UAwCXS,GAAaT,GAvCI,QAwCjBU,GAAU5B,GAAK,KAChB6B,OAAM,kBAAM5D,GAAQmC,GAAW,CAC5B0B,GACAZ,GAAMF,IACND,GAASG,GAAMD,KACfa,SAEFA,GAAqBf,GAASY,IAAY/H,KAAI,SAAAgF,GAAM,OAAIA,GAAU,MAClEmD,GAAkBhB,GAASa,IAAShI,KAAI,SAAAgF,GAAM,OAAIA,GAAU,aAGnD,IACXM,UACA8C,IAzWQ,SAACC,GAAD,OAAe,IAAI/C,IAAO,SAACG,GACnC,IAAQC,EAAiCD,EAAjCC,aAAcT,EAAmBQ,EAAnBR,MAGtB,GAHyCQ,EAAZP,QAGd,OAAOO,EAGtB,IAAM+B,EAAe9B,EAAaI,MAAMb,GACxC,OAA4B,IAAxBuC,EAAa7L,OACNyJ,GAAkBK,EAAD,+BAAsC4C,EAAtC,uCAIxBb,EAAac,WAAWD,GAEjBtD,GAAkBU,EAAa4C,EAAGpD,EAAQoD,EAAE1M,QAGhDyJ,GAAkBK,EAAD,8BAAqC4C,EAArC,oBAAkD3C,EAAaI,MAAMb,EAAOA,EAAQ,IAApF,YAwVxBmB,QACAI,cACA+B,OAlRW,SAAU9B,GAAV,OAAmC,IAAInB,IAAO,SAACG,GAC1D,GAAIA,EAAYP,QAAW,OAAOO,EADwD,oBAM1EgB,GAN0E,IAM1F,2BAAyB,CAAC,IAChBR,EADe,QACDE,MAAMV,GAC1B,IAAIQ,EAAUf,QAAW,OAAOe,GARsD,8BAY1F,OAAOb,GAAkBK,EAAD,mEAA0EA,EAAYR,MAAtF,UAuQxBuD,QA1KY,SAAUC,EAAuBC,GAAjC,OAA4D,SAACC,GAAD,OAA8BnC,GAAW,CACjHiC,EACAE,EACAD,IACD1I,KAAI,SAAA0G,GAAO,OAAIA,EAAQ,QAuKtBC,QACAiC,MA9LU,SAAItE,GAAJ,OAA0BqC,GAAKrC,GAAQ,IA+LjDwC,SACA+B,OAxLW,SAAO9B,EAA4BC,GAAnC,OAA8DF,GAAWC,GAAiB,EAA5BD,CAAkCE,IAyL3G8B,WAlIe,SAAIC,GAAJ,OAAqE,IAAIzD,IAAO,SAAAG,GAO/F,IANA,IAAMuD,EAAYD,IAEdE,OAAYC,EACZjD,EAAYR,IAGH,CACT,IAAMT,EAASgE,EAAUG,KAAKF,GACxBlL,EAAQiH,EAAOjH,MAIrB,GAHaiH,EAAOoE,KAIhB,OAAOrE,GAAkBkB,EAAWlI,GAIxC,KAAMA,GAASA,aAAiBuH,IAChC,MAAM,IAAIO,MAAJ,0DACiDb,EAAOjH,MADxD,MAON,IADAkI,EAAYlI,EAAMoI,MAAMF,IACVf,QACV,OAAOe,EAGXgD,EAAYhD,EAAUjB,YAqG1BmC,YACAkC,UA/Ec,SAAI/E,GAAJ,OAAqC,IAAIgB,IAAO,SAAAG,GAC9D,GAAIA,EAAYP,QAAW,OAAOO,EAElC,IAAMQ,EAAY3B,EAAO6B,MAAMV,GAC/B,OAAOQ,EAAUf,QACbE,GAAkBK,EAAaQ,EAAUd,OAEzCJ,GAAkBU,EAAaQ,EAAUjB,YA0E7CsC,SACAK,WACAC,UACAC,UACAC,SACAC,cACAC,WACAE,sBACAC,mBAEAmB,KAhLS,SAAIC,GAAJ,OAAoC,IAAIjE,IAAO,SAAAG,GAExD,OADe8D,IACDpD,MAAMV,OA+KpB+D,KArKS,SAAIC,GAAJ,OAAwC,IAAInE,IAAO,SAAAG,GAC5D,OAAOL,GAAkBK,EAAagE,OAqKtCC,QA5JY,SAAI3L,GAAJ,OAA8B,IAAIuH,IAAO,SAAAG,GACrD,OAAOV,GAAkBU,EAAa1H,OA6JtCgH,qBACAK,sB,qCCpgBSuE,GAAc,CACvBC,SAA4BxF,GAAOvI,EAAYgO,UAC/CC,WAA4B1F,GAAOvI,EAAYkO,aAC/CC,SAA4B5F,GAAOvI,EAAYoO,UAC/CvK,QAA4B0E,GAAOvI,EAAYqO,SAE/CC,OAA4B/F,GAAOvI,EAAYuO,SAC/CC,QAA4BjG,GAAOvI,EAAYyO,UAC/CC,WAA4BnG,GAAOvI,EAAY2O,aAE/CC,gBAA4BrG,GAAOvI,EAAY6O,kBAC/CC,oBAA4BvG,GAAOvI,EAAY8I,sBAC/CiG,0BAA4BxG,GAAOvI,EAAYgP,6BAE/ClI,MAA4ByB,GAAOvI,EAAYiP,OAC/CC,YAA4B3G,GAAOvI,EAAYmP,aAE/CC,KAA4B7G,GAAOvI,EAAYqP,MAC/CC,SAA4B/G,GAAOvI,EAAYuP,UAC/CC,UAA4BjH,GAAOvI,EAAYyP,WAC/CC,YAA4BnH,GAAOvI,EAAY2P,eCT7CC,GAAkB,SAACpD,GAAD,OAAuCqD,GAAInD,OAAO,CACtEmD,GAAItD,IAAIC,EAAEsD,eACVD,GAAItD,IAAIC,EAAEuD,kBAMRC,GAA+BH,GAAIrC,UAAkBqC,GAAIpE,MAAM,OAK/DsC,GACF8B,GAAInD,OAAOpL,KAAU6C,KAAI,SAAA8L,GAAa,OAAIL,GAAgBK,OACtD9L,IAAI2J,GAAYC,UAKlBmC,GAAmCL,GAAIpE,MAAM,gBAK7CwC,GACF4B,GAAItF,KAAK,KACL6B,OAAM,kBAAM5D,GAAQqH,GAAI9C,MAAMmD,QAC9B/L,IAAI2J,GAAYG,YAKlBpK,GACFgM,GAAItF,KAAK,KACL6B,OAAM,kBAAM5D,GAAQqH,GAAI9C,MAAMmD,QAC9B/L,IAAI2J,GAAYjK,SAKlBsM,GAAuB3H,GAAQqH,GAAIlF,WAAW,CAChDkF,GAAIpE,MAAM,cACVoE,GAAIvE,SAASuE,GAAIpE,MAAM,mBACnBtH,KAAI,SAAAiM,GAAC,OAAU,OAANA,EAAa,GAAKA,QAM7BjC,GAAW0B,GAAItD,IAAI,KACpBH,OAAM,kBAAM+D,MACZhM,IAAI2J,GAAYK,UAKfkC,GAAWR,GAAInD,OAAO,CACxBmD,GAAItF,KAAK,KAAKpG,IAAI2J,GAAYQ,QAC9BuB,GAAItF,KAAK,KAAKpG,IAAI2J,GAAYU,SAC9BqB,GAAItF,KAAK,KAAKpG,IAAI2J,GAAYY,cAM5B5H,GAAyB+I,GAAIlF,WAAW,CAC1CwF,GACAN,GAAItF,KAAK,KACTsF,GAAIxD,qBAEPlI,KAAI,0CACJA,IAAI2J,GAAYhH,OAEXwJ,GAA+BT,GAAIlD,QAAQkD,GAAIxD,mBAAoBwD,GAAIxD,oBACvEkE,GAAiBV,GAAI5E,MAAMqF,GAA6BT,GAAItF,KAAK,OClFjEmF,GAAcG,GAAI5C,WAAJ,WAAe,yFAC/B,OAD+B,SACzB4C,GAAItF,KAAK,KADgB,OAET,OAFS,SAEH4F,GAFG,OAG/B,OADMK,EAFyB,gBAGzBX,GAAItF,KAAK,KAHgB,OAK/B,OAL+B,SAKzBsF,GAAIxD,mBALqB,OAMhB,OANgB,UAMV8D,GANU,QAO/B,OADMM,EANyB,iBAOzBZ,GAAItF,KAAK,KAPgB,QAQd,OARc,UAQR4F,GARQ,QAS/B,OADMO,EARyB,iBASzBb,GAAIxD,mBATqB,iCAWxByB,GAAY4B,YAAY,CAC3Bc,gBACAC,SACAC,cAd2B,4CCA7BC,GAAoBd,GAAInD,OAAO,CACjCuB,GACAE,GACAuB,KASEkB,GAAgBf,GAAI5C,WAAJ,WAAe,+FAUjC,OAViC,SAC5B4D,OAD4B,+BAC5BA,IAD4B,6DAC5BA,IAD4B,2DAC5BA,IAD4B,kCAC5BA,MAD4B,KAQ3BC,EAAQ,CADRjI,EAAO,IAPoB,SAU3BgH,GAAItF,KAAK,KAVkB,OAY7B9J,EAAQoQ,EAAOE,2BAEfC,GAAO,EAdsB,WAe1BA,EAf0B,iBAgBJ,OAhBI,UAgBEhB,GAhBF,QAgBvBiB,EAhBuB,YAkBtBxQ,EAlBsB,cAmBpBoQ,EAAOK,aAnBa,UA4BpBL,EAAOM,4BA5Ba,UAwCpBN,EAAOE,2BAxCa,UAyDpBF,EAAOO,cAzDa,oBAoBrB,OApBqB,UAoBfvB,GAAItF,KAAK,KApBM,QAuBrB,OAFA1B,EAAK9C,KAAK,IACV+K,EAAM/K,KAAKsC,GAAKQ,IAtBK,UAuBfgH,GAAIxD,mBAvBW,eAwBrB5L,EAAQoQ,EAAOE,2BAxBM,kCA6BJ,MAAbE,EA7BiB,wBA8BjBxQ,EAAQoQ,EAAOO,cA9BE,+BAkCJ,OAlCI,KAkCrB/I,GAAKyI,GAlCgB,UAkCET,GAlCF,QAmCrB,OAnCqB,iBAkCTtK,KAlCS,0BAmCf8J,GAAIxD,mBAnCW,eAoCrB5L,EAAQoQ,EAAOE,2BApCM,kCAyCJ,MAAbE,EAzCiB,iBA0CjB,OA1CiB,UA0CXpB,GAAIlC,KAAa,gCA1CN,+CA8CJ,MAAbsD,EA9CiB,iBA+CjBxQ,EAAQoQ,EAAOK,aA/CE,wBAkDA,OAlDA,KAkDjB7I,GAAKyI,GAlDY,UAkDMH,GAlDN,QAmDjB,OAnDiB,iBAkDL5K,KAlDK,0BAmDX8J,GAAIxD,mBAnDO,QAoDjB5L,EAAQoQ,EAAOM,4BApDE,8CA0DrB,OA1DqB,UA0DftB,GAAItF,KAAK,KA1DM,WA2DrBuG,EAAMO,MACe,IAAjBP,EAAMhR,OA5DW,wBA6DjBkR,GAAO,EA7DU,6BAiErB,OAjEqB,UAiEfnB,GAAIxD,mBAjEW,eAkErB5L,EAAQoQ,EAAOM,4BAlEM,qCAuEf,IAAInH,MAAM,iFAvEK,wDA4E1BpB,GAA0BC,IA5EA,4CAoF/ByI,GAAoBzB,GAAI5C,WAAJ,WAAe,+FAOrC,OAPqC,SAChC4D,OADgC,mCAChCA,IADgC,sCAChCA,MADgC,KAKjCpQ,EAAQoQ,EAAOU,eALkB,SAO/B1B,GAAItF,KAAK,KAPsB,OAQrC,OARqC,SAQ/BsF,GAAIxD,mBAR2B,OAU/BxD,EAAO,GAETmI,GAAO,EAZ0B,WAa9BA,EAb8B,sBAc1BvQ,EAd0B,cAexBoQ,EAAOU,eAfiB,UA2BxBV,EAAOW,gBA3BiB,oBAiBV,OAjBU,UAiBJ3B,GAAInD,OAAO,CAC5BkE,GACAD,KAnBqB,QAuBzB,OANMxH,EAjBmB,OAqBzBN,EAAK9C,KAAKoD,GACV1I,EAAQoQ,EAAOW,gBAtBU,UAuBnB3B,GAAIxD,mBAvBe,8CA4BA,OA5BA,UA4BM2D,GA5BN,WA6BR,MA7BQ,wBA8BrB,OA9BqB,UA8BfH,GAAItF,KAAK,KA9BM,QA+BrB,OA/BqB,UA+BfsF,GAAIxD,mBA/BW,eAgCrB2E,GAAO,EAhCc,6BAoCV,OApCU,UAoCJX,GApCI,QAuCzB,OAHMlH,EApCmB,OAqCzBN,EAAK9C,KAAKoD,GACV1I,EAAQoQ,EAAOU,eAtCU,UAuCnB1B,GAAIxD,mBAvCe,oDA4CnB,IAAIrC,MAAM,sFA5CS,wDAgD9B8D,GAAYiB,0BAA0BlG,IAhDR,4CAiDtC1E,KFlDmC,SAAhCsN,EAAiC5I,GACnC,GAAIA,EAAKT,OAASpI,EAAYgP,6BACvBnG,EAAKT,OAASpI,EAAY8I,qBAC7B,OAAOD,EAIX,GAA0B,IAAtBA,EAAK3G,MAAMpC,OACX,OAAO+I,EAAK3G,MAAM,GAiBtB,IAdA,IAAMwP,EAAsB,CACxB/C,YAAa,EACbJ,QAAS,EACTE,SAAU,GAGVkD,EAAsB,CACtBC,UAAWC,IACXC,QAAS,KACTC,SAAU,KACVC,GAAI,MAICnS,EAAI,EAAGA,EAAIgJ,EAAK3G,MAAMpC,OAAQD,GAAG,EAAG,CACzC,IAAMoS,EAAQP,EAAoB7I,EAAK3G,MAAMrC,GAAGuI,MAC5C6J,EAAQN,EAAoBC,WAC5BD,EAAsB,CAClBC,SAAUK,EACVH,QAASjS,EAAI,EACbkS,SAAUlS,EAAI,EACdmS,GAAInJ,EAAK3G,MAAMrC,KAO3B,IAAMqS,EAAgBpE,GAAYgB,oBAAZ,sBACfjG,EAAK3G,MAAM+H,MAAM,EAAG0H,EAAoBG,UADzB,CAElBhE,GAAYc,gBAAgB,CACxBuD,EAAGV,EAA8B5I,EAAK3G,MAAMyP,EAAoBG,UAChEM,EAAGX,EAA8B5I,EAAK3G,MAAMyP,EAAoBI,WAChEC,GAAIL,EAAoBK,MALV,YAOfnJ,EAAK3G,MAAM+H,MAAM0H,EAAoBI,SAAW,MAGvD,OAAON,EAA8BS,MH5InCjF,GAAa,SAACoF,GAAD,OAA6CxC,GAAI5C,WAAoBoF,IAUlFC,GAAS,SAACnK,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAIvE,OAJuE,SAIjE2D,GAAInD,OAAO,CAC1BuB,GACAqD,KANgF,OASpF,OALMiB,EAJ8E,gBAS9E1C,GAAIxD,mBAT0E,OAUpF,OAVoF,UAU9EwD,GAAItF,KAAK,KAVqE,QAWpF,OAXoF,UAW9EsF,GAAIxD,mBAX0E,QAavE,OAbuE,UAajE0B,GAbiE,QAcpF,OADMyE,EAb8E,iBAc9E3C,GAAIxD,mBAd0E,QAepF,OAfoF,UAe9EwD,GAAIvD,gBAf0E,iCAiB7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACF,EAAMC,MAnBmE,6CA+BlFE,GAAS,SAACvK,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAIvE,OAJuE,SAIjE6B,GAJiE,OAMpF,OAFMwE,EAJ8E,gBAM9E1C,GAAIxD,mBAN0E,OAOpF,OAPoF,UAO9EwD,GAAItF,KAAK,KAPqE,QAQpF,OARoF,UAQ9EsF,GAAIxD,mBAR0E,QAUvE,OAVuE,UAUjEwD,GAAInD,OAAO,CAC1BuB,GACAqD,KAZgF,QAcpF,OAJMkB,EAV8E,iBAc9E3C,GAAIxD,mBAd0E,QAepF,OAfoF,UAe9EwD,GAAIvD,gBAf0E,iCAiB7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACF,EAAMC,MAnBmE,6CA+BlFG,GAAS,SAACxK,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAIzE,OAJyE,SAInE6B,GAJmE,OAMpF,OAFM6E,EAJ8E,gBAM9E/C,GAAIxD,mBAN0E,OAOpF,OAPoF,UAO9EwD,GAAItF,KAAK,KAPqE,QAQpF,OARoF,UAQ9EsF,GAAIxD,mBAR0E,QAUzE,OAVyE,UAUnE0B,GAVmE,QAWpF,OADM8E,EAV8E,iBAW9EhD,GAAIxD,mBAX0E,QAYpF,OAZoF,UAY9EwD,GAAIvD,gBAZ0E,iCAc7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACG,EAAIC,MAhBqE,6CA4BlFC,GAAS,SAAC3K,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAIzE,OAJyE,SAInE6B,GAJmE,OAMpF,OAFM6E,EAJ8E,gBAM9E/C,GAAIxD,mBAN0E,OAOpF,OAPoF,UAO9EwD,GAAItF,KAAK,KAPqE,QAQpF,OARoF,UAQ9EsF,GAAIxD,mBAR0E,QAWvE,OAXuE,UAWjEwD,GAAInD,OAAO,CAC1B7I,GACAgM,GAAItF,KAAK,KAAK6B,OAAM,kBAAMkF,QAbsD,QAgBpF,OALMyB,EAX8E,iBAgB9ElD,GAAIxD,mBAhB0E,QAiBpF,OAjBoF,UAiB9EwD,GAAIvD,gBAjB0E,iCAmB7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACG,EAAIG,MArBqE,6CAkElFC,GAAS,SAAC7K,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAIxE,OAJwE,SAIlE2D,GAAInD,OAAO,CACzBuB,GACAqD,KANgF,OASpF,OALM2B,EAJ8E,gBAS9EpD,GAAIxD,mBAT0E,OAUpF,OAVoF,UAU9EwD,GAAItF,KAAK,KAVqE,QAWpF,OAXoF,UAW9EsF,GAAIxD,mBAX0E,QAYpF,OAZoF,UAY9EwD,GAAIvD,gBAZ0E,QAcvE,OAduE,UAcjEuD,GAAInD,OAAO,CAC1B7I,GACAgM,GAAItF,KAAK,KAAK6B,OAAM,kBAAMkF,QAhBsD,QAmBpF,OALMyB,EAd8E,iBAmB9ElD,GAAIxD,mBAnB0E,iCAqB7EyB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACQ,EAAKF,MAvBoE,6CAsGlFG,GAAS,SAAC/K,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,+EACpF,OADoF,SAC9E2C,GAAgBzH,GAD8D,OAEpF,OAFoF,SAE9E0H,GAAIxD,mBAF0E,OAGpF,OAHoF,SAG9EwD,GAAIvD,gBAH0E,gCAK7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,MAP0E,4CAmBlFU,GAAY,SAAChL,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,qFACvF,OADuF,SACjF2C,GAAgBzH,GADiE,OAEvF,OAFuF,SAEjF0H,GAAI3D,WAF6E,OAI5E,OAJ4E,SAItE6B,GAJsE,OAKvF,OADM6E,EAJiF,gBAKjF/C,GAAIxD,mBAL6E,OAMvF,OANuF,UAMjFwD,GAAIvD,gBAN6E,iCAQhFwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACG,MAV4E,6CAsBrFQ,GAAY,SAACjL,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,qFACvF,OADuF,SACjF2C,GAAgBzH,GADiE,OAEvF,OAFuF,SAEjF0H,GAAI3D,WAF6E,OAI3E,OAJ2E,SAIrE2D,GAAInD,OAAO,CACzBuB,GACAqD,KANmF,OAQvF,OAJM2B,EAJiF,gBAQjFpD,GAAIxD,mBAR6E,OASvF,OATuF,UASjFwD,GAAIvD,gBAT6E,iCAWhFwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACQ,MAb4E,6CM/SvFI,GAuBAC,KAvBAD,IACAE,GAsBAD,KAtBAC,IACAC,GAqBAF,KArBAE,IACAC,GAoBAH,KApBAG,IACAC,GAmBAJ,KAnBAI,IACAC,GAkBAL,KAlBAK,GACAC,GAiBAN,KAjBAM,IACAC,GAgBAP,KAhBAO,IACAC,GAeAR,KAfAQ,IACAC,GAcAT,KAdAS,IACAC,GAaAV,KAbAU,IACAC,GAYAX,KAZAW,IACAC,GAWAZ,KAXAY,IACAC,GAUAb,KAVAa,IACAC,GASAd,KATAc,IACAC,GAQAf,KARAe,IACAC,GAOAhB,KAPAgB,IACAC,GAMAjB,KANAiB,IACAC,GAKAlB,KALAkB,IACAC,GAIAnB,KAJAmB,IACAC,GAGApB,KAHAoB,IACAC,GAEArB,KAFAqB,IACAC,GACAtB,KADAsB,IAMEC,GAAMhF,GAAInD,OAAO,CACnBiG,GAAOU,GAAKyB,KAAgBzB,IAAKV,QACjCL,GAAOe,GAAKyB,KAAgBzB,IAAKf,SNiGrBnK,GMhGLkL,GNgGoCjL,GMhG/B0M,KAAgBzB,IAAK0B,ONgGwC9H,GAAU,WAAC,uFACpF,OADoF,SAC9E2C,GAAgBzH,IAD8D,OAEpF,OAFoF,SAE9E0H,GAAI3D,WAF0E,OAKvE,OALuE,SAKjE2D,GAAInD,OAAO,CAC1B7I,GACAgM,GAAItF,KAAK,KAAK6B,OAAM,kBAAMkF,QAPsD,OAUpF,OALMyB,EAL8E,gBAU9ElD,GAAIxD,mBAV0E,OAWpF,OAXoF,UAW9EwD,GAAItF,KAAK,KAXqE,QAYpF,OAZoF,UAY9EsF,GAAIxD,mBAZ0E,QAczE,OAdyE,UAcnE0B,GAdmE,QAgBpF,OAFM6E,EAd8E,iBAgB9E/C,GAAIxD,mBAhB0E,QAiBpF,OAjBoF,UAiB9EwD,GAAIvD,gBAjB0E,iCAmB7EwB,GAAYoB,YAAY,CAC3BA,YAAa9G,GACbqK,KAAM,CAACM,EAAMH,MArBmE,6CM/FpFE,GAAOO,GAAKyB,KAAgBzB,IAAKP,QACjCE,GAAOK,GAAKyB,KAAgBzB,IAAKL,QNkKnB,SAAC7K,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,uFACvF,OADuF,SACjF2C,GAAgBzH,GADiE,OAEvF,OAFuF,SAEjF0H,GAAI3D,WAF6E,OAI5E,OAJ4E,SAItE2D,GAAItF,KAAK,KAAK6B,OAAM,kBAAM2B,MAJ4C,OAMvF,OAFM6E,EAJiF,gBAMjF/C,GAAIxD,mBAN6E,OAOvF,OAPuF,UAOjFwD,GAAItF,KAAK,KAPwE,QAQvF,OARuF,UAQjFsF,GAAIxD,mBAR6E,QAU5E,OAV4E,UAUtE0B,GAVsE,QAYvF,OAFM8E,EAViF,iBAYjFhD,GAAIxD,mBAZ6E,QAavF,OAbuF,UAajFwD,GAAIvD,gBAb6E,iCAehFwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACG,EAAIC,MAjBwE,4CMjKvFmC,CAAU3B,GAAKyB,KAAgBzB,IAAK2B,WN8LtB,SAAC7M,EAA+BC,GAAhC,OAA8D6E,GAAU,WAAC,yFACvF,OADuF,SACjF2C,GAAgBzH,GADiE,OAEvF,OAFuF,SAEjF0H,GAAI3D,WAF6E,OAI3E,OAJ2E,SAIrE2D,GAAInD,OAAO,CACzBuB,GACAqD,KANmF,OASvF,OALM2B,EAJiF,gBASjFpD,GAAIxD,mBAT6E,OAUvF,OAVuF,UAUjFwD,GAAItF,KAAK,KAVwE,QAWvF,OAXuF,UAWjFsF,GAAIxD,mBAX6E,QAa5E,OAb4E,UAatEwD,GAAItF,KAAK,KAAK6B,OAAM,kBAAM2B,MAb4C,QAevF,OAFM6E,EAbiF,iBAejF/C,GAAIxD,mBAf6E,QAgBvF,OAhBuF,UAgBjFwD,GAAItF,KAAK,KAhBwE,QAiBvF,OAjBuF,UAiBjFsF,GAAIxD,mBAjB6E,QAmB5E,OAnB4E,UAmBtE0B,GAnBsE,QAqBvF,OAFM8E,EAnBiF,iBAqBjFhD,GAAIxD,mBArB6E,QAsBvF,OAtBuF,UAsBjFwD,GAAIvD,gBAtB6E,iCAwBhFwB,GAAYoB,YAAY,CAC3BA,YAAa9G,EACbqK,KAAM,CAACQ,EAAKL,EAAIC,MA1BmE,4CM7LvFoC,CAAU5B,GAAKyB,KAAgBzB,IAAK4B,aAGlCzP,GAAMqK,GAAInD,OAAO,CACnBiG,GAAOY,GAAKuB,KAAgBvB,IAAKZ,QACjCL,GAAOiB,GAAKuB,KAAgBvB,IAAKjB,UAG/B4C,GAAMrF,GAAInD,OAAO,CACnBiG,GAAOa,GAAKsB,KAAgBtB,IAAKb,QACjCD,GAAOc,GAAKsB,KAAgBtB,IAAKd,QACjCJ,GAAOkB,GAAKsB,KAAgBtB,IAAKlB,UAG/B6C,GAAMtF,GAAInD,OAAO,CACnBiG,GAAOc,GAAKqB,KAAgBrB,IAAKd,QACjCL,GAAOmB,GAAKqB,KAAgBrB,IAAKnB,UAG/B8C,GAAMvF,GAAInD,OAAO,CACnBiG,GAAOe,GAAKoB,KAAgBpB,IAAKf,QACjCD,GAAOgB,GAAKoB,KAAgBpB,IAAKhB,UAG/B2C,GAAKxF,GAAInD,OAAO,CAClBiG,GAAOgB,GAAImB,KAAgBnB,IAAIhB,QAC/BD,GAAOiB,GAAImB,KAAgBnB,IAAIjB,UAG7B4C,GAAMzF,GAAInD,OAAO,CACnBiG,GAAOiB,GAAKkB,KAAgBlB,IAAKjB,QACjCD,GAAOkB,GAAKkB,KAAgBlB,IAAKlB,UAG/B6C,GAAM1F,GAAInD,OAAO,CACnBiG,GAAOkB,GAAKiB,KAAgBjB,IAAKlB,QACjCD,GAAOmB,GAAKiB,KAAgBjB,IAAKnB,UAG/B8C,GAAM3F,GAAInD,OAAO,CACnBiG,GAAOmB,GAAKgB,KAAgBhB,IAAKnB,QACjCD,GAAOoB,GAAKgB,KAAgBhB,IAAKpB,UAG/B+C,GAAMtC,GAAUY,GAAKe,KAAgBf,IAAKZ,WAC1CuC,GAAMvC,GAAUa,GAAKc,KAAgBd,IAAKb,WAC1CwC,GAAMxC,GAAUc,GAAKa,KAAgBb,IAAKd,WAE1CyC,GAAM/F,GAAInD,OAAO,CACnBoG,GAAOoB,GAAKY,KAAgBZ,IAAKpB,QACjCE,GAAOkB,GAAKY,KAAgBZ,IAAKlB,UAG/B6C,GAAMhG,GAAInD,OAAO,CACnBoG,GAAOqB,GAAKW,KAAgBX,IAAKrB,QACjCE,GAAOmB,GAAKW,KAAgBX,IAAKnB,UAG/B8C,GAAMjG,GAAInD,OAAO,CACnBoG,GAAOsB,GAAKU,KAAgBV,IAAKtB,QACjCE,GAAOoB,GAAKU,KAAgBV,IAAKpB,UAG/B+C,GAAMlG,GAAInD,OAAO,CACnBoG,GAAOuB,GAAKS,KAAgBT,IAAKvB,QACjCE,GAAOqB,GAAKS,KAAgBT,IAAKrB,UAG/BgD,GAAMnG,GAAInD,OAAO,CACnBoG,GAAOwB,GAAKQ,KAAgBR,IAAKxB,QACjCE,GAAOsB,GAAKQ,KAAgBR,IAAKtB,UAG/BiD,GAAMpG,GAAInD,OAAO,CACnBoG,GAAOyB,GAAKO,KAAgBP,IAAKzB,QACjCE,GAAOuB,GAAKO,KAAgBP,IAAKvB,UAG/BkD,GAAMrG,GAAInD,OAAO,CACnB0G,GAAUoB,GAAKM,KAAgBN,IAAKpB,WACpCD,GAAUqB,GAAKM,KAAgBN,IAAKrB,aAGlC9B,GAAM8B,GAAUsB,GAAKK,KAAgBL,IAAKtB,WAE1CgD,GAAMtG,GAAInD,OAAO,CACnB0G,GAAUsB,GAAKI,KAAgBJ,IAAKtB,WACpCD,GAAUuB,GAAKI,KAAgBJ,IAAKvB,aAGlCiD,GAAMlD,GAAOyB,GAAKG,KAAgBH,IAAKzB,QACvCmD,GAAMnD,GAAO0B,GAAKE,KAAgBF,IAAK1B,QAEhChE,GAAcW,GAAInD,OAAO,CAClCmI,GAEArP,GACA0P,GACAC,GACAE,GACAD,GACAE,GACAK,GACAJ,GACAC,GAEAC,GACAC,GAEAG,GACAD,GACAE,GACAC,GACAC,GACAC,GAEAC,GACA7E,GACA8E,GACAC,GACAC,KCjKEC,GAAa,SAACtQ,GAAD,OAAmC6J,GAAI5C,WAAJ,WAAe,yFACxC,OADwC,KAChDsJ,QADgD,SAClC1G,GAAIvE,SAASuE,GAAItF,KAAK,MADY,OAEjE,OAFiE,YAC3DiM,GAD2D,uBAE3D3G,GAAItD,IAAJ,cAAevG,IAF4C,OAIjE,OAJiE,SAI3D6J,GAAI3D,WAJuD,OAKpD,OALoD,UAK9CiE,GAL8C,QAMjE,OADM7P,EAL2D,iBAM3DuP,GAAI3D,WANuD,QAOjE,OAPiE,UAO3D2D,GAAItF,KAAK,KAPkD,QAQjE,OARiE,UAQ3DsF,GAAI3D,WARuD,QASjE,OATiE,UAS3D2D,GAAItF,KAAK,KATkD,QAUjE,OAViE,UAU3DsF,GAAI3D,WAVuD,QAYlD,OAZkD,UAY5CqE,GAAetC,IAZ6B,QAajE,OADMwI,EAZ2D,iBAa3D5G,GAAIxD,mBAbuD,QAcjE,OAdiE,UAc3DwD,GAAItF,KAAK,KAdkD,QAejE,OAfiE,UAe3DsF,GAAIxD,mBAfuD,iCAiB1DyB,GAAYsB,KAAK,CACpBpJ,OACAwQ,WACAlW,OACAmW,YArB6D,6CA0B/DC,GAAQJ,GAAW,GACnBK,GAASL,GAAW,IC9BpBM,GAAkC/G,GAAI5C,WAAJ,WAAe,yFAC1B,OAD0B,KAClCsJ,QADkC,SACpB1G,GAAIvE,SAASuE,GAAItF,KAAK,MADF,OAEnD,OAFmD,YAC7CiM,GAD6C,uBAE7C3G,GAAItD,IAAI,YAFqC,OAGnD,OAHmD,SAG7CsD,GAAI3D,WAHyC,OAItC,OAJsC,UAIhCiE,GAJgC,QAKnD,OADM7P,EAJ6C,iBAK7CuP,GAAI3D,WALyC,QAOnD,OAPmD,UAO7C2D,GAAItF,KAAK,KAPoC,QAQnD,OARmD,UAQ7CsF,GAAI3D,WARyC,QASrC,OATqC,UAS/B+B,GAT+B,QAUnD,OADM/L,EAT6C,iBAU7C2N,GAAIxD,mBAVyC,iCAY5CyB,GAAYwB,SAAS,CACxBkH,WACAlW,OACA4B,WAf+C,4CCAjD2U,GAAehH,GAAI5C,WAAJ,WAAe,uFAChC,OADgC,SAC1B4C,GAAIxD,mBADsB,OAEpB,OAFoB,SAEd8D,GAFc,OAIhC,OAFM2G,EAF0B,gBAI1BjH,GAAIxD,mBAJsB,OAKhC,OALgC,SAK1BwD,GAAItF,KAAK,KALiB,OAMhC,OANgC,UAM1BsF,GAAIxD,mBANsB,QAQlB,OARkB,UAQZ4B,GARY,QAShC,OADM/L,EAR0B,iBAS1B2N,GAAIxD,mBATsB,iCAWzB,CAAEyK,MAAK5U,UAXkB,4CAsB9B6U,GAAmClH,GAAI5C,WAAJ,WAAe,yFAC3B,OAD2B,KACnCsJ,QADmC,SACrB1G,GAAIvE,SAASuE,GAAItF,KAAK,MADD,OAGpD,OAHoD,YAC9CiM,GAD8C,uBAG9C3G,GAAItD,IAAI,aAHsC,OAIpD,OAJoD,SAI9CsD,GAAI3D,WAJ0C,OAMvC,OANuC,UAMjCiE,GANiC,QAOpD,OADM7P,EAN8C,iBAO9CuP,GAAI3D,WAP0C,QAQpD,OARoD,UAQ9C2D,GAAItF,KAAK,KARqC,QASpD,OAToD,UAS9CsF,GAAI3D,WAT0C,QAWpC,OAXoC,UAW9BqE,GAAesG,IAXe,QAapD,OAFMG,EAX8C,iBAa9CnH,GAAIxD,mBAb0C,QAcpD,OAdoD,UAc9CwD,GAAItF,KAAK,KAdqC,QAepD,OAfoD,UAe9CsF,GAAIxD,mBAf0C,iCAiB7CyB,GAAY0B,UAAU,CACzBgH,WACAlW,OACA0W,aApBgD,4CCtB3CC,GAAiBpH,GAAI/E,KAC9B+E,GAAInD,OAAO,CACPwC,GACApI,GACA4P,GACAC,GACArH,GACAE,GACAK,GAAI1D,WCRC+K,GAAM5V,KAAU6V,QAAO,SAACC,EAAgCC,EAAiB/Q,GAElF,OADA8Q,EAAOC,EAAQvH,eAAiBxJ,EACzB8Q,IACR,ICLCE,GAAc,GACdC,GAAqB,GACrBC,GAAS,GACTC,GAAa,GAQXC,GAAe,SAAAC,GACjB,OAAOA,EAAKvP,MACR,KAAKpI,EAAYoO,SACb,KAAMuJ,EAAKzV,SAASsV,IAChB,MAAM,IAAIxN,MAAJ,gBAAmB2N,EAAKzV,MAAxB,sBAEV,OAAOsV,GAAOG,EAAKzV,OAGvB,KAAKlC,EAAY2P,aACb,IAAMH,EAAYiI,GAAWE,EAAKzV,MAAMsO,eAExC,IAAKhB,EACD,MAAM,IAAIxF,MAAJ,qBAAwB2N,EAAKzV,MAAMsN,UAAnC,6BAGV,IAAMoI,EAASpI,EAAUwH,QAAQW,EAAKzV,MAAMwO,UAC5C,IAAKkH,EACD,MAAM,IAAI5N,MAAJ,mBACU2N,EAAKzV,MAAMwO,SADrB,2BACgDiH,EAAKzV,MAAMsN,UAD3D,6BAKV,KAAMmI,EAAKzV,MAAMuO,UAAU+G,IACvB,MAAM,IAAIxN,MAAJ,iBAAoB2N,EAAKzV,MAAMuO,OAA/B,4BAIV,OADe+G,GAAOG,EAAKzV,MAAMuO,QACjBmH,EAAOC,OAG3B,KAAK7X,EAAYkO,YAIjB,KAAKlO,EAAYqO,QACb,OAAQpG,SAAS0P,EAAKzV,MAAO,IAIjC,QACI,MAAM,IAAI8H,MAAJ,iCAAoC2N,EAAKvP,SASrD0P,GAAoB,SAAAC,GACtB,IAAMC,EAASN,GAAaK,GACtBE,GAAqB,MAATD,IAAoB,EAChCE,EAAmB,IAATF,EAChBV,GAAYvR,KAAKkS,EAAUC,IAiBzBC,GAAY,SAAApK,GACd,IAAMqK,EAAYlB,GAAInJ,EAAS7L,MAAM4N,eACrCwH,GAAYvR,KAAKqS,IA8BfC,GAAgB,SAAC/X,GAAD,OAAkBA,KAAQkX,IAAUlX,KAAQmX,IAOrDa,GAAW,SAACC,GAErBjB,GAAc,GACdC,GAAqB,GACrBC,GAAS,GACTC,GAAa,GAGb,IAAMe,EAAe/P,GAAOgQ,IAAIF,GAC1BG,EAAMF,EAAarP,OAAOwP,QAAO,SAAAhB,GAAI,MAAoB,kBAATA,KAGtD,GAAIa,EAAanP,QACb,MAAM,IAAIW,MAAMwO,EAAalP,OAMjC,IAAIsP,EAAiB,EACrB,GAAI,WAAYJ,EAAc,CAC1BE,EAAIG,SAAQ,SAAAlB,GACR,OAAOA,EAAKvP,MACR,KAAKpI,EAAYiP,MAEb,GAAIoJ,GAAcV,EAAKzV,OACnB,MAAM,IAAI8H,MAAJ,+BACqB2N,EAAKzV,MAD1B,4CAMV,YADAsV,GAAOG,EAAKzV,OAAS0W,GAIzB,KAAK5Y,EAAYuP,SACb,GAAI8I,GAAcV,EAAKzV,MAAM5B,MACzB,MAAM,IAAI0J,MAAJ,kCACwB2N,EAAKzV,MAAM5B,KADnC,4CAMV,YADAkX,GAAOG,EAAKzV,MAAM5B,MAA+C,MAAvC2H,SAAS0P,EAAKzV,MAAMA,MAAMA,MAAO,KAI/D,KAAKlC,EAAYqP,KAEb,GAAIgJ,GAAcV,EAAKzV,OACnB,MAAM,IAAI8H,MAAJ,8BACoB2N,EAAKzV,MADzB,4CAKVsV,GAAOG,EAAKzV,MAAM5B,MAAQsY,EAC1B,IAAME,EAAwC,KAApBnB,EAAKzV,MAAM8D,KAAe,EAAG,EACjD+S,EAAapB,EAAKzV,MAAMuU,OAAO3W,OAASgZ,EAE9C,YADAF,GAAkBG,GAItB,KAAK/Y,EAAYyP,UAEb,GAAI4I,GAAcV,EAAKzV,MAAM5B,MACzB,MAAM,IAAI0J,MAAJ,mCACyB2N,EAAKzV,MAAM5B,KADpC,4CAKVmX,GAAWE,EAAKzV,MAAM5B,MAAQ,CAC1B0W,QAAS,IAGb,IAAIa,EAAS,EAUb,YATAF,EAAKzV,MAAM8U,QAAQ7S,KAAI,YAAmB,IAAjB2S,EAAgB,EAAhBA,IAAK5U,EAAW,EAAXA,MAC1BuV,GAAWE,EAAKzV,MAAM5B,MAAM0W,QAAQF,GAAO,CACvCe,SACA7R,KAAkC,MAA5BiC,SAAS/F,EAAMA,MAAO,KAGhC2V,GAAUJ,GAAWE,EAAKzV,MAAM5B,MAAM0W,QAAQF,GAAK9Q,QAO3D,QACI,IAAMgT,EAAWC,KAAiBtB,EAAKzV,MAAMgN,aAE7C,YADA0J,GAAkBI,EAAShT,UAWvC,IAGIkT,EAAe,EACnBR,EAAIG,SAAQ,SAAAlB,GAER,IANmB,SAACA,GAAD,OAAYA,EAAKvP,OAASpI,EAAYiP,OAAW0I,EAAKvP,OAASpI,EAAYuP,UAAcoI,EAAKvP,OAASpI,EAAYyP,UAMlI0J,CAAexB,GACd,GAAIA,EAAKvP,OAASpI,EAAYqP,KAA9B,CAUL,IAAM2J,EAAWC,KAAiBtB,EAAKzV,MAAMgN,aAC7CoI,GAAYvR,KAAKiT,EAASI,QAG1B7B,GAAmBxR,KAAK,CACpBmJ,YAAa8J,EAAS9J,YACtBuD,KAAMkF,EAAKzV,MAAMuQ,KAAKtO,KAAI,SAAAkO,GACtB,OAAIzM,MAAMqC,SAASoK,EAAInQ,QAAgBmQ,EAAInQ,MACrC,KAAN,OAAYmQ,EAAInQ,MAAMlB,SAAS,IAAIoD,SAAS,EAAG,SAEnDgF,MAAO8P,IAEXA,GAAgBF,EAAShT,KAGrB,CAACqT,KAAE/G,OAAQ+G,KAAEtE,QAAQuE,SAASN,EAAS5Q,OACvC0P,GAAkBH,EAAKzV,MAAMuQ,KAAK,IAClC0F,GAAUR,EAAKzV,MAAMuQ,KAAK,KAErB,CAAC4G,KAAE3G,OAAQ2G,KAAEvG,QAAQwG,SAASN,EAAS5Q,OAC5C+P,GAAUR,EAAKzV,MAAMuQ,KAAK,IAC1BqF,GAAkBH,EAAKzV,MAAMuQ,KAAK,KAE7B4G,KAAEE,UAAYP,EAAS5Q,MAC5B+P,GAAUR,EAAKzV,MAAMuQ,KAAK,IA9LpB,SAAAsF,GAClB,IACMG,EAAmB,IADVR,GAAaK,GAE5BT,GAAYvR,KAAKmS,GA4LLsB,CAAc7B,EAAKzV,MAAMuQ,KAAK,KAEzB,CAAC4G,KAAE1G,OAAQ0G,KAAErE,WAAWsE,SAASN,EAAS5Q,OAC/C+P,GAAUR,EAAKzV,MAAMuQ,KAAK,IAC1B0F,GAAUR,EAAKzV,MAAMuQ,KAAK,KAEtB4G,KAAErG,SAAWgG,EAAS5Q,MAC1B0P,GAAkBH,EAAKzV,MAAMuQ,KAAK,IAClCqF,GAAkBH,EAAKzV,MAAMuQ,KAAK,KAE7B4G,KAAEpE,YAAc+D,EAAS5Q,MAC9B0P,GAAkBH,EAAKzV,MAAMuQ,KAAK,IAClC0F,GAAUR,EAAKzV,MAAMuQ,KAAK,IAC1B0F,GAAUR,EAAKzV,MAAMuQ,KAAK,KAErB4G,KAAElG,YAAc6F,EAAS5Q,KAC9B+P,GAAUR,EAAKzV,MAAMuQ,KAAK,IAErB4G,KAAEjG,YAAc4F,EAAS5Q,MAC9B0P,GAAkBH,EAAKzV,MAAMuQ,KAAK,SArDV,IAApBkF,EAAKzV,MAAM8D,KA1IX,SAAA2R,GAChBA,EAAKzV,MAAMuU,OAAOtS,KAAI,SAAAP,GAClB,IAAM6V,EAAcxR,SAASrE,EAAK1B,MAAO,IACzCoV,GAAYvR,KAAmB,IAAd0T,MAwILC,CAAY/B,GAjIX,SAAAA,GACjBA,EAAKzV,MAAMuU,OAAOtS,KAAI,SAAAP,GAClB,IAAM6V,EAAcxR,SAASrE,EAAK1B,MAAO,IACzCoV,GAAYvR,MAAoB,MAAd0T,IAAyB,GAC3CnC,GAAYvR,KAAmB,IAAd0T,MA+HLE,CAAahC,MAwD7B,MAAO,CAAEiC,UAAWtC,GAAaC,wB,8CC1RhCsC,G,2BCHQC,IALUC,KAAOC,IAAV,kFAKDD,KAAOE,IAAV,iPAeHC,GAAOH,KAAOC,IAAV,sDAIJG,GAASJ,KAAOK,KAAV,2IAQNC,GAAcN,KAAOK,KAAV,uD,2CC2GTE,GAjIK,WAChB,MAAwBxV,mBAAwB,KAAhD,mBAAO3F,EAAP,KAAa4F,EAAb,KACMwV,EAAevX,EAAepB,GAC9BH,EAAKuB,EAAezB,GAsB1B,GAjBAyD,qBAAU,WACN,IAEIC,EAFEuV,EAASpV,SAASC,uBAAT,iBAA0C5D,EAAGT,SAAS,IAAIoD,SAAS,EAAG,OAQrF,OALIoW,EAAO,KACPvV,EAASuV,EAAO,IACTjV,UAAUC,IAAI,mBAGlB,WAAO,IAAD,EACH,QAAN,EAAAP,SAAA,SAAQM,UAAUE,OAAO,wBAO5B8U,EAAgB,OAAO,KAE5B,IAAKA,EAAapb,GAAgD,OAAvC4F,EAAQ6B,OAAOC,KAAK0T,GAAc,IAAY,KAEzE,IAAKA,EAAapb,GAAMW,OAAU,OAAO,KAGzC,IAAM2a,EAAcF,EAAapb,GAAMgF,KAAI,SAAA+K,GAAW,MAClD,UAAGA,EAAYA,YAAf,OAAkCA,EAAYuD,KAAK0E,QAAO,SAACuD,EAAWrI,EAAK/L,GACvE,IAAMqU,EAAerU,IAAQ4I,EAAYuD,KAAK3S,OAAS,EAAK,GAAK,IAEjE,OADA4a,GAAS,UAAOrI,GAAP,OAAasI,EAAb,OAEV,OACJhS,KAAK,MAIFiS,EAAc,SAAC,GAAyB,IAAvB7T,EAAsB,EAAtBA,MAAU8T,EAAY,mBAI3C,OACI,iCACI9T,MAAK,uCAAOA,GALD,CACf+T,gBAAiB,6BAIR,IAA6BC,aAAc,UAC5CF,KAId,OACI,sBAAK9T,MAAO,CAACd,OAAQ,OAAQ0B,MAAO,OAAQqT,SAAU,YAAtD,UACE,cAAC,KAAD,CACEA,SAAU,WACVC,KAAM,qBACNC,OAAQ,EACRvT,MAAO,GACP1B,OAAQ,GACRkV,WAAY,GACZ/U,cAAe,GACfgV,GAAG,UACHC,YAAY,UACZrU,MAAM,UACNsU,WAAY,kDACZ9T,aAAcZ,OAAOC,KAAK0T,GAAc,GACxCzS,SAAU,SAAA/D,GAAC,OAAIgB,EAAQhB,EAAEmE,OAAOhG,QAblC,SAiBM0E,OAAOC,KAAK0T,GAAcpW,KAAI,SAACoX,EAAiBjV,GAAlB,OAC5B,wBAAkBpE,MAAOqZ,EAAzB,qBAAgDtT,SAASsT,EAAiB,IAAIva,SAAS,IAAIoD,SAAS,EAAG,OAA1FkC,QAIrB,cAAC,KAAD,2BACMkV,MADN,IAEEC,KAAMhB,EACNiB,SAAS,MAHX,SAKG,gBAAGnV,EAAH,EAAGA,UAAWQ,EAAd,EAAcA,MAAO4U,EAArB,EAAqBA,OAAQC,EAA7B,EAA6BA,aAAcC,EAA3C,EAA2CA,cAA3C,OACG,cAAC/B,GAAD,CAAKvT,UAAWA,EAAWQ,MAAK,eAAMA,GAAtC,SACE,cAAC,cAAD,CACE+U,UAAQ,EACRC,gBAAiB,IACjBC,iBAAkB,IAClBC,oBAAqBrB,EACrBsB,WACE,kBAAM,qBAAKnV,MAAO,CACdO,QAAS,OACT6U,cAAe,SACfnB,SAAU,WACVoB,MAAO,MACPC,SAAU,SACVC,YAAa,QACblW,aAAc,QACdmW,cAAe,YAdvB,SAkBCZ,EAAOxX,KAAI,SAACqY,EAAMpT,GACjB,IAAMqT,EAAYb,EAAa,CAAEY,OAAM1F,IAAK1N,IAG5C,OAFAqT,EAAUlW,WAAV,4BAAqCgU,EAAapb,GAAMiK,GAAOA,MAAMpI,SAAS,IAAIoD,SAAS,EAAG,OAG5F,eAAC8V,GAAD,2BAAsBuC,GAAtB,cACE,cAACtC,GAAD,sBAAcI,EAAapb,GAAMiK,GAAOA,MAAMpI,SAAS,IAAIoD,SAAS,EAAG,QACvE,cAACiW,GAAD,UACGmC,EAAKrY,KAAI,SAACuY,EAAO5F,GAAR,OACR,kCAAM/P,MAAO,CACTY,MAAO,IACPgV,SAAU,IACVC,SAAU,MACGf,EAAc,CAAEa,QAAO5F,SAAhCA,WARH1N,mB,SF7G5ByQ,K,oBAAAA,E,6BAAAA,Q,KAaL,IAAMgD,GAAS,SAAChC,EAAoBtW,GAChC,IAAMuY,EAAWha,IACXyV,EAAelR,iBAAO,IACtBiQ,EAAcjQ,iBAAO,IAC3B,EAA4BvC,mBAAS+U,GAAWkD,UAAhD,mBAAOC,EAAP,KAAeC,EAAf,KACMC,EAAY7V,iBAAO,MACnB8V,EGxBK,WACX,IAAMC,EAASC,eACf,EAAoCvY,mBAAS,IAA7C,mBAAOqY,EAAP,KAAmBG,EAAnB,KAGMC,EAAW3W,OAAO6P,OAAOnD,MAC1BqF,QAAO,SAAAzW,GAAK,MAAqB,kBAAVA,KACvBiV,QAAO,SAAC7O,EAAKkV,GAGV,OAFAlV,EAAIvC,KAAKyX,GACTlV,EAAIvC,KAAKyX,EAAQ1N,eACVxH,IACR,IAGDmV,EAAO,0FAyDb,GAvDAzY,qBAAU,WACN,GAAKoY,EAAL,CAEA,IAAMD,EAAa,WACnBG,EAAcH,GAEdC,EAAOM,UAAU3P,SAAS,CAAE1J,GAAI8Y,IAGhCC,EAAOM,UAAUC,yBAAyB,WAAW,CACjDC,aAAc,UACdL,WACAM,aAAc,CAAC,WAAY,QAAS,SAAU,aAC9CC,UAAW,CAAC,IAAK,IAAK,IAAK,IAAK,KAGhCC,QAAU,wBACVC,QAAS,wEACTC,UAAW,iCAEXC,UAAW,CACPC,KAAM,CACF,CAACV,EAAM,mBACP,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,eAGnB,CAAC,gBAAiB,CACdW,MAAO,CAAE,gBAAiB,UACf,YAAa,UACb,WAAY,gBAG3B,CAAEC,QAAS,eACX,CAAC,eAAgB,mBACjB,CAAC,0BAA2B,CAAE3B,MAAO,aAAczY,IAAK,yBAExD,CAAC,WAAY,mBAGb,CAAC,aAAc,aACf,CAAC,mBAAoB,aAGrB,CAAC,YAAa,mBAElBiI,WAAY,CACR,CAAC,aAAc,IACf,CAAC,UAAW,kBAIzB,CAACkR,IAGe,KAAfD,EACA,OAAOA,EHhDQmB,GAKbC,EAAe,kBAAMhG,EAAavQ,QAAUkV,EAAUlV,QAAQwW,YAc9DC,EAAmB,SAACrW,GACtByS,EAAM6D,mBAAmBtW,GAAQyR,GAAW8E,cAC5C1B,EAAU7U,IASRwW,EAAsB,SAACzf,EAAcyB,GAIvC,IAAIgZ,EAAqBrC,EInDXsH,EANGC,KAAMC,UJuDvBR,IAIA,IAAI,MAEqCjG,IAAgBC,EAAavQ,QAAQgX,OAAS,MA1B7CC,QAAQ,kBAAmB,OA0B9DrF,EAFH,EAEGA,UAAWrC,EAFd,EAEcA,mBIvDJsH,EJwDG,uBIxDkBC,KAAMjR,QAAQgR,EAAS,CAC9D7D,SAAU,eACVkE,UAAW,IACXC,cAAc,EACdC,cAAc,EACdC,WAAW,EACXnc,MAAO,OACP6D,MAAO,CAACa,SAAU,MJkDZ,MAAO7D,GAGL,YI9CO,SAAC8a,GAAoBC,KAAMxV,MAAMuV,EAAS,CACzD7D,SAAU,YACVkE,UAAW,IACXI,iBAAiB,EACjBH,cAAc,EACdC,cAAc,EACdC,WAAW,EACXE,cAAUlS,EACVnK,MAAO,OACP6D,MAAO,CAACa,SAAU,MJoCV4X,CAAWzb,EAAE8a,SAMjBvH,EAAYtP,QAAU4R,EAAUzC,QAAO,SAACsE,EAAM7X,EAAMD,GAEhD,OADA8X,GAAQ,YAAK7X,EAAK5C,SAAS,IAAIoD,SAAS,EAAG,MAAS,MAErD,IAEH0Y,EAAS/b,EAAQ,CAACb,KAAMqX,EAAoBpY,OAAMyB,WAClD6d,EAAiB5E,GAAW8E,eAyBhC,GAVAjZ,8BAAoBnB,GAAK,iBAAO,CAC5Bqa,oBAD4B,SACPzf,EAAcyB,GAC/Bge,EAAoBzf,EAAMyB,IAE9B6e,WAJ4B,SAIhBtgB,EAAcyB,IAXX,SAACzB,EAAcyB,GAC9B,IAAM8e,EAAepI,EAAYtP,QAAQ2X,MAAM,KAAKxb,KAAI,SAAAP,GAAI,OAAIqE,SAASrE,EAAM,OAC/EkZ,EAAStc,EAAY,CAACtB,QAASwgB,EAAcvgB,OAAMyB,WAU/C6e,CAAWtgB,EAAMyB,OAErB,KAGCuc,EAAc,OAAO,KAO1B,OACI,qCACA,cAAC,KAAD,IACA,sBAAK5W,UAAU,WAAf,UACI,wBAAQA,UAAYyW,IAAWnD,GAAWkD,SAAY,oBAAsB,aAAc6C,QAAS,kBAAMnB,EAAiB5E,GAAWkD,WAArI,sBACA,wBAAQ8C,UAAWvI,EAAYtP,QAASzB,UAAYyW,IAAWnD,GAAW8E,aAAgB,oBAAsB,aAAciB,QAAS,kBAAMnB,EAAiB5E,GAAW8E,eAAzK,uBAEJ,sBAAKpY,UAAU,SAAf,UACI,cAAC,KAAD,CACIN,OAAS+W,IAAWnD,GAAWkD,SAAY,MAAQ,MACnD7a,MAAQ8a,IAAWnD,GAAWkD,SAAYxE,EAAavQ,QAAUsP,EAAYtP,QAC7EF,SAAWyW,EACX7C,SAAWyB,EACX2C,QAjBiB,SAAC9C,EAAQrZ,GAClCuZ,EAAUlV,QAAUgV,GAiBZ+C,QAAS,CAAC,SAAY,GAAI,gBAAkB,GAC5C7c,MAAM,YAGL8Z,IAAWnD,GAAW8E,cACvB,qBAAK5X,MAAO,CAACd,OAAQ,OAArB,SACI,cAAC,GAAD,aAQLQ,wBAAWoW,I,yFK/HXmD,GAZF,SAACnF,GAAD,OACT,cAAC,KAAD,2BAAUA,GAAV,aACI,cAAC,KAAD,CACIoF,WAAW,mCACXC,OAAO,OACPtY,SAAS,KAAKH,WAAW,YAH7B,0B,oBCiDO0Y,GAjDK,SAAC,GAAsB,IAArBrY,EAAoB,EAApBA,SAAUsY,EAAU,EAAVA,KAC5B,EAAsCC,IAAMvb,SAAS,GAArD,mBAAOwb,EAAP,KAAoBC,EAApB,KACA,EAAsCF,IAAMvb,UAAS,GAArD,mBAAO0b,EAAP,KAAoBC,EAApB,KAEA,OACE,eAAC,KAAD,CACEpc,GAAG,SACHmD,aAAc,EACd0C,IAAK,GACLwW,IAAK,IACL/Y,MAAO,IACPxB,YAAY,OACZ2B,SAAU,SAAC6Y,GAAQJ,EAAeI,GAAI7Y,EAAS6Y,IAC/CC,aAAc,kBAAMH,GAAe,IACnCI,aAAc,kBAAMJ,GAAe,IATrC,UAWE,cAAC,KAAD,CACErF,GAAG,WACHpU,MAAM,QACN8Z,UAAU,YACVC,OAAQX,EACRtZ,MAAK,gBALP,eAOA,cAAC,KAAD,CAAY5E,MAAO,GAAI8e,GAAG,IAAIC,GAAG,OAAOrZ,SAAS,KAAjD,iBAGA,cAAC,KAAD,CAAY1F,MAAO,GAAI8e,GAAG,IAAIC,GAAG,OAAOrZ,SAAS,KAAjD,iBAGA,cAAC,KAAD,CAAY1F,MAAO,GAAI8e,GAAG,IAAIC,GAAG,OAAOrZ,SAAS,KAAjD,iBAGA,cAAC,KAAD,UACE,cAAC,KAAD,MAEF,cAAC,KAAD,CACEsZ,UAAQ,EACR9F,GAAG,WACHpU,MAAM,QACN8Z,UAAU,MACVC,OAAQP,EACR1Z,MAAK,UAAKwZ,EAAL,KANP,SAQE,cAAC,KAAD,U,qCC1BJa,GAAY,kBAChB,sBAAKxZ,MAAM,KAAKyZ,QAAQ,YAAYC,MAAM,6BAA1C,UACE,0CACA,sBACEC,KAAK,QACLC,EAAE,mNAQFC,GAAW,kBACf,sBACE7Z,MAAM,OACNyZ,QAAQ,YACRC,MAAM,6BACNC,KAAK,QAJP,UAME,yCACA,sBAAMC,EAAE,oDAONE,GAAa,SAAC,GAAwB,IAAtBC,EAAqB,EAArBA,OAAQX,EAAa,EAAbA,OAC5B,OACE,cAAC,KAAD,CAAKzZ,QAAS,CAAEnI,KAAM,QAASwiB,GAAI,QAAU/B,QAAS8B,EAAtD,SACGX,EAAS,cAAC,GAAD,IAAgB,cAAC,GAAD,OAQ1Ba,GAAc,SAAC,GAAqC,IAAnCC,EAAkC,EAAlCA,SAAuBC,GAAW,EAAxBC,GAAwB,oBACvD,OACI,cAAC,KAAD,yBAAMC,OAAO,UAAU1a,QAAQ,SAAYwa,GAA3C,aACGD,MAQHI,GAAY,SAAC,GAAoH,IAAlHlB,EAAiH,EAAjHA,OAAQmB,EAAyG,EAAzGA,eAAgBC,EAAyF,EAAzFA,iBAAkBC,EAAuE,EAAvEA,WAAYC,EAA2D,EAA3DA,UAAWC,EAAgD,EAAhDA,eAAgBC,EAAgC,EAAhCA,iBAAkBC,EAAc,EAAdA,QACtH,EAAuCC,eAA/BC,EAAR,EAAQA,UAAWC,EAAnB,EAAmBA,gBACbC,EAAWvC,IAAMhZ,OAAO,GACxBwb,EAAQxC,IAAMhZ,QAAO,GAE3B,OACE,cAAC,KAAD,CACEC,QAAS,CAAEnI,KAAM4hB,EAAS,QAAU,OAAQY,GAAI,SAChDmB,UAAW,CAAE3jB,KAAM,OAAQwiB,GAAI,QAFjC,SAIE,eAAC,KAAD,CACEoB,QAAS,EACTC,MAAM,SACNC,QAAS,CAAC,SAAU,gBAAiB,WAAY,YACjDC,UAAW,CAAC,SAAU,SAAU,MAAO,OACvCC,GAAI,CAAC,EAAG,EAAG,EAAG,GALhB,UAOE,cAAC,GAAD,CACEnc,MAAOub,EAAmB,OAAS,UACnCa,OAAQ,CACNpc,MAAOub,EAAmB,OAAS,WACnCP,OAAQO,EAAmB,UAAY,UACvCc,WAAY,cAEdzD,QAAS,kBAAO2C,GAAoBL,EAAeU,EAAS5a,QAAS6a,EAAM7a,UAP7E,wBAQA,cAAC,KAAD,CACEsb,QAAQ,OACRF,OAAQ,CACNpc,MAAO,WACPqc,WAAY,aACZrB,OAAQ,WAEVpC,QAAS,kBAAMuC,EAAiBS,EAAS5a,QAAS6a,EAAM7a,UAP1D,kBAWA,cAAC,KAAD,CACEF,SAAU,SAAA/D,GAAC,OAAI8e,EAAM7a,QAAUjE,EAAEmE,OAAOqb,SAD1C,oBAKA,cAAC,IAAD,CACIlf,GAAG,OACHmD,aAAc,OACdR,MAAO,WACPS,WAAY,OACZC,UAAW,EACXzB,OAAQ,OACR0B,MAAO,OACPC,SAAU,OACVC,QAAS,MACTC,SAAU,SAAAC,GAAK,OAAI6a,EAAS5a,QAAUC,SAASF,EAAMG,OAAOhG,MAAO,OAEvE,cAAC,GAAD,CACEkhB,OAAQ,CACNpc,MAAO,WACPqc,WAAY,cAEdzD,QAASwC,EALX,oBAMA,cAAC,GAAD,CAAahC,KAAMW,EAAQjZ,SAAU,SAAC5F,GAAD,OAAWogB,EAAepgB,MAC/D,cAAC,GAAD,UACE,cAAC,KAAD,CACE8D,KAAK,KACLwd,QAAQ,KACRxc,MAAO,CAAC,QAAS,QAAS,QAAS,SACnCoU,GAAI,CAAC,WAAY,WAAY,WAAY,YACzCgI,OAAQ,CACNhI,GAAI,CAAC,WAAY,WAAY,WAAY,aAE3CwE,QAASyC,EARX,SAUIG,EAAU,OAAS,UAGzB,cAAC,GAAD,UACE,eAAC,KAAD,CACExc,KAAK,KACLwd,QAAQ,KACRxc,MAAO,CAAC,QAAS,QAAS,QAAS,aACnCoU,GAAI,CAAC,WAAY,WAAY,WAAY,YACzCgI,OAAQ,CACNhI,GAAI,CAAC,WAAY,WAAY,WAAY,aAE3CwE,QAAS+C,EARX,oBAUwB,UAAdD,EAAwB,OAAS,mBAW/Ce,GAAkB,SAAC,GAA4B,IAA1B5B,EAAyB,EAAzBA,SAAahH,EAAY,mBAClD,OACE,cAAC,KAAD,yBACE6I,GAAG,MACHV,MAAM,SACNC,QAAQ,gBACRU,KAAK,OACLC,EAAE,OACFC,GAAI,EACJC,EAAG,EACH1I,GAAG,UACHpU,MAAM,SACF6T,GAVN,aAYGgH,MAKQkC,GArLA,SAAClJ,GACd,MAA4BwF,IAAMvb,UAAS,GAA3C,mBAAOic,EAAP,KAAeiD,EAAf,KAGA,OACE,eAAC,GAAD,2BAAqBnJ,GAArB,cACE,cAAC,GAAD,IACA,cAAC,GAAD,CAAY6G,OALD,kBAAMsC,GAAWjD,IAKAA,OAAQA,IACpC,cAAC,GAAD,2BAAelG,GAAf,IAAsBkG,OAAQA,UC0DrBkD,GAlEH,WACV,IAAMnH,EAAWha,IACjB,EAA8BgC,oBAAS,GAAvC,mBAAO0d,EAAP,KAAgB0B,EAAhB,KACA,EAA8Cpf,oBAAS,GAAvD,mBAAOqf,EAAP,KAAwBzF,EAAxB,KACM0F,EAAW/c,iBALG,IAMd6V,EAAY7V,mBACZgd,EAAgBhd,iBAAY,MAC5BlH,EAAO6C,EAAenB,GAE5BmD,qBAAU,WACJ7E,GAAQkkB,EAAcrc,SAASsc,cAAcD,EAAcrc,WAC9D,CAAC7H,IA+BJ,OACE,sBAAKoG,UAAU,eAAf,UACE,cAAC,GAAD,CACE2b,eAAgB,SAAC/iB,GAAD,IAAeyB,EAAf,+DAA0Csc,EAAUlV,SAAWkV,EAAUlV,QAAQ4W,oBAAoBzf,EAAMyB,IAC3HuhB,iBAAkB,SAAChjB,GAAD,IAAeyB,EAAf,+DAA0Csc,EAAUlV,SAAWkV,EAAUlV,QAAQyX,WAAWtgB,EAAMyB,IACpH2hB,iBAAkB4B,EAClB/B,WAAY,kBAAMtF,EAASjc,MAC3BwhB,UAAW,kBA7BC,WAChB,IAAMkC,EAAa/B,EAInB,GAFA0B,GAAY1B,GAER+B,EAGF,OAFAD,cAAcD,EAAcrc,cAC5Bqc,EAAcrc,QAAU,MAI1B8U,EAAS7b,KAGT,IAAMujB,EAhBK,IAgBWJ,EAASpc,QAAU,IAApB,IACrBqc,EAAcrc,QAAUyc,aAAY,WACjC3H,EAASjc,OACT2jB,GAYkBnC,IACjBC,eAAgB,SAACoC,GAAD,OAVExiB,EAUmCwiB,EAVjBN,EAASpc,QAAU9F,EAAtC,IAACA,GAWlBsgB,QAASA,IAGX,sBAAKjc,UAAU,cAAf,UACI,qBAAKA,UAAU,SAAf,SACE,cAAC,GAAD,CAAQhC,IAAK2Y,EAAWwB,mBAAoBA,MAE9C,qBAAKnY,UAAU,iBAAf,SACE,cAAC,EAAD,aC3DZoe,IAASC,OACP,cAAC,IAAD,UACE,cAAC,IAAD,CAAe1hB,MAAOA,EAAtB,SACE,eAAC,IAAD,CAAUR,MAAOA,EAAjB,UACE,cAAC,IAAD,CAAiBW,iBAAkBH,EAAME,OAAOC,mBAChD,cAAC,GAAD,WAIN+B,SAASyf,eAAe,U,+ICbdC,E,wBAAAA,K,gBAAAA,E,gBAAAA,E,kBAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,gBAAAA,E,sBAAAA,E,sBAAAA,E,gBAAAA,E,sBAAAA,E,uBAAAA,M,KAkBZ,IAgBYxR,EAoCAyR,EApDNC,GAAgC,mBACjCF,EAAiBxS,OAAS,GADO,cAEjCwS,EAAiBpS,OAAS,GAFO,cAGjCoS,EAAiBvL,QAAU,GAHM,cAIjCuL,EAAiBnS,OAAS,GAJO,cAKjCmS,EAAiBhS,OAAS,GALO,cAMjCgS,EAAiB/P,OAAS,GANO,cAOjC+P,EAAiB9R,OAAS,GAPO,cAQjC8R,EAAiB9P,UAAY,GARI,cASjC8P,EAAiB7P,UAAY,GATI,cAUjC6P,EAAiB5R,OAAS,GAVO,cAWjC4R,EAAiB3R,UAAY,GAXI,cAYjC2R,EAAiB1R,UAAY,GAZI,I,SAgB1BE,K,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,QAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,eAAAA,M,cAoCAyR,K,wBAAAA,E,sBAAAA,E,wBAAAA,E,wBAAAA,E,0BAAAA,E,kCAAAA,E,kCAAAA,E,sBAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,sBAAAA,E,kBAAAA,E,kBAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,0BAAAA,E,wBAAAA,E,wBAAAA,E,0BAAAA,E,0BAAAA,E,UAAAA,E,wBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,kBAAAA,E,gBAAAA,E,UAAAA,E,kBAAAA,E,gBAAAA,E,UAAAA,E,UAAAA,E,UAAAA,E,mBAAAA,M,KAwDL,IAAMjQ,GAAe,mBACvBxB,EAAoBD,IAAM,CACvBV,OAAYoS,EAAYE,UACxB3S,OAAYyS,EAAYG,WACxBnQ,OAAYgQ,EAAYI,WACxBrS,OAAYiS,EAAYK,WACxBpS,OAAY+R,EAAYM,YACxBrQ,UAAa+P,EAAYO,gBACzBrQ,UAAa8P,EAAYQ,kBARL,cAUvBjS,EAAoBC,IAAM,CACvBZ,OAASoS,EAAYS,UACrBlT,OAASyS,EAAYU,cAZD,cAcvBnS,EAAoBE,IAAM,CACvBb,OAASoS,EAAYW,UACrBhT,OAASqS,EAAYY,YACrBrT,OAASyS,EAAYa,cAjBD,cAmBvBtS,EAAoBG,IAAM,CACvBd,OAASoS,EAAYc,YACrBvT,OAASyS,EAAYe,cArBD,cAuBvBxS,EAAoBI,IAAM,CACvBf,OAASoS,EAAYgB,YACrBrT,OAASqS,EAAYiB,cAzBD,cA2BvB1S,EAAoBK,GAAK,CACtBhB,OAASoS,EAAYkB,WACrBvT,OAASqS,EAAYmB,aA7BD,cA+BvB5S,EAAoBM,IAAM,CACvBjB,OAASoS,EAAYoB,YACrBzT,OAASqS,EAAYqB,cAjCD,cAmCvB9S,EAAoBO,IAAM,CACvBlB,OAAQoS,EAAYsB,YACpB3T,OAAQqS,EAAYuB,cArCA,cAuCvBhT,EAAoBQ,IAAM,CACvBnB,OAAQoS,EAAYwB,YACpB7T,OAAQqS,EAAYyB,cAzCA,cA2CvBlT,EAAoBS,IAAM,CACvBZ,UAAW4R,EAAY0B,UA5CH,cA8CvBnT,EAAoBU,IAAM,CACvBb,UAAW4R,EAAY2B,UA/CH,cAiDvBpT,EAAoBW,IAAM,CACvBd,UAAW4R,EAAY9Q,MAlDH,cAoDvBX,EAAoBY,IAAM,CACvBpB,OAAQiS,EAAY4B,QACpB3T,OAAQ+R,EAAY6B,UAtDA,cAwDvBtT,EAAoBa,IAAM,CACvBrB,OAAQiS,EAAY8B,QACpB7T,OAAQ+R,EAAY+B,aA1DA,cA4DvBxT,EAAoBc,IAAM,CACvBtB,OAAQiS,EAAYgC,QACpB/T,OAAQ+R,EAAYiC,UA9DA,cAgEvB1T,EAAoBe,IAAM,CACvBvB,OAAQiS,EAAYkC,QACpBjU,OAAQ+R,EAAYmC,UAlEA,cAoEvB5T,EAAoBgB,IAAM,CACvBxB,OAAQiS,EAAYoC,QACpBnU,OAAQ+R,EAAYqC,UAtEA,cAwEvB9T,EAAoBiB,IAAM,CACvBzB,OAAQiS,EAAYsC,QACpBrU,OAAQ+R,EAAYuC,UA1EA,cA4EvBhU,EAAoBkB,IAAM,CACvBrB,UAAW4R,EAAYwC,OACvBnU,UAAW2R,EAAYyC,UA9EH,cAgFvBlU,EAAoBmB,IAAM,CACvBtB,UAAW4R,EAAYtQ,MAjFH,cAmFvBnB,EAAoBoB,IAAM,CACvBvB,UAAW4R,EAAY0C,OACvBrU,UAAW2R,EAAY2C,UArFH,cAuFvBpU,EAAoBqB,IAAM,CACvBzB,OAAQ6R,EAAYpQ,MAxFA,cA0FvBrB,EAAoBsB,IAAM,CACvB1B,OAAQ6R,EAAYnQ,MA3FA,GAyGtB+S,EAAU,SAAC7S,GAAD,MAAwC,CACpD1M,KAAM0c,EAAiBhQ,GACvB9O,KAAMgf,EAAgBlQ,KAIpBmE,GAAiC,mBAClC8L,EAAYG,WADsB,yBAE/BhW,YAAa6V,EAAYG,WACzB9L,OAAQ,IACLuO,EAAQ7C,EAAiBxS,SAJG,IAK/BnK,SAAUmL,EAAoBD,OALC,cAOlC0R,EAAYE,UAPsB,yBAQ/B/V,YAAa6V,EAAYE,UACzB7L,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SAVG,IAW/BxK,SAAUmL,EAAoBD,OAXC,cAalC0R,EAAYK,WAbsB,yBAc/BlW,YAAa6V,EAAYK,WACzBhM,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SAhBG,IAiB/B3K,SAAUmL,EAAoBD,OAjBC,cAmBlC0R,EAAYI,WAnBsB,yBAoB/BjW,YAAa6V,EAAYI,WACzB/L,OAAQ,IACLuO,EAAQ7C,EAAiB/P,SAtBG,IAuB/B5M,SAAUmL,EAAoBD,OAvBC,cAyBlC0R,EAAYM,YAzBsB,yBA0B/BnW,YAAa6V,EAAYM,YACzBjM,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SA5BG,IA6B/B7K,SAAUmL,EAAoBD,OA7BC,cA+BlC0R,EAAYO,gBA/BsB,yBAgC/BpW,YAAa6V,EAAYO,gBACzBlM,OAAQ,IACLuO,EAAQ7C,EAAiB9P,YAlCG,IAmC/B7M,SAAUmL,EAAoBD,OAnCC,cAqClC0R,EAAYQ,gBArCsB,yBAsC/BrW,YAAa6V,EAAYQ,gBACzBnM,OAAQ,IACLuO,EAAQ7C,EAAiB7P,YAxCG,IAyC/B9M,SAAUmL,EAAoBD,OAzCC,cA4ClC0R,EAAYS,UA5CsB,yBA6C/BtW,YAAa6V,EAAYS,UACzBpM,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SA/CG,IAgD/BxK,SAAUmL,EAAoBC,OAhDC,cAkDlCwR,EAAYU,YAlDsB,yBAmD/BvW,YAAa6V,EAAYU,YACzBrM,OAAQ,IACLuO,EAAQ7C,EAAiBxS,SArDG,IAsD/BnK,SAAUmL,EAAoBC,OAtDC,cAwDlCwR,EAAYa,YAxDsB,yBAyD/B1W,YAAa6V,EAAYa,YACzBxM,OAAQ,IACLuO,EAAQ7C,EAAiBxS,SA3DG,IA4D/BnK,SAAUmL,EAAoBE,OA5DC,cA8DlCuR,EAAYY,YA9DsB,yBA+D/BzW,YAAa6V,EAAYY,YACzBvM,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SAjEG,IAkE/BvK,SAAUmL,EAAoBE,OAlEC,cAoElCuR,EAAYW,UApEsB,yBAqE/BxW,YAAa6V,EAAYW,UACzBtM,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SAvEG,IAwE/BxK,SAAUmL,EAAoBE,OAxEC,cA0ElCuR,EAAY0B,QA1EsB,yBA2E/BvX,YAAa6V,EAAY0B,QACzBrN,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YA7EG,IA8E/BhL,SAAUmL,EAAoBS,OA9EC,cAgFlCgR,EAAY2B,QAhFsB,yBAiF/BxX,YAAa6V,EAAY2B,QACzBtN,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YAnFG,IAoF/BhL,SAAUmL,EAAoBU,OApFC,cAsFlC+Q,EAAYe,YAtFsB,yBAuF/B5W,YAAa6V,EAAYe,YACzB1M,OAAQ,IACLuO,EAAQ7C,EAAiBxS,SAzFG,IA0F/BnK,SAAUmL,EAAoBG,OA1FC,cA4FlCsR,EAAYc,YA5FsB,yBA6F/B3W,YAAa6V,EAAYc,YACzBzM,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SA/FG,IAgG/BxK,SAAUmL,EAAoBG,OAhGC,cAmGlCsR,EAAYuB,YAnGsB,yBAoG/BpX,YAAa6V,EAAYuB,YACzBlN,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SAtGG,IAuG/BvK,SAAUmL,EAAoBO,OAvGC,cAyGlCkR,EAAYsB,YAzGsB,yBA0G/BnX,YAAa6V,EAAYsB,YACzBjN,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SA5GG,IA6G/BxK,SAAUmL,EAAoBO,OA7GC,cA+GlCkR,EAAYyB,YA/GsB,yBAgH/BtX,YAAa6V,EAAYuB,YACzBlN,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SAlHG,IAmH/BvK,SAAUmL,EAAoBQ,OAnHC,cAqHlCiR,EAAYwB,YArHsB,yBAsH/BrX,YAAa6V,EAAYwB,YACzBnN,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SAxHG,IAyH/BxK,SAAUmL,EAAoBQ,OAzHC,cA2HlCiR,EAAYiB,YA3HsB,yBA4H/B9W,YAAa6V,EAAYiB,YACzB5M,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SA9HG,IA+H/BvK,SAAUmL,EAAoBI,OA/HC,cAiIlCqR,EAAYgB,YAjIsB,yBAkI/B7W,YAAa6V,EAAYgB,YACzB3M,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SApIG,IAqI/BxK,SAAUmL,EAAoBI,OArIC,cAuIlCqR,EAAYmB,WAvIsB,yBAwI/BhX,YAAa6V,EAAYmB,WACzB9M,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SA1IG,IA2I/BvK,SAAUmL,EAAoBK,MA3IC,cA6IlCoR,EAAYkB,WA7IsB,yBA8I/B/W,YAAa6V,EAAYkB,WACzB7M,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SAhJG,IAiJ/BxK,SAAUmL,EAAoBK,MAjJC,cAmJlCoR,EAAYqB,YAnJsB,yBAoJ/BlX,YAAa6V,EAAYqB,YACzBhN,OAAQ,IACLuO,EAAQ7C,EAAiBpS,SAtJG,IAuJ/BvK,SAAUmL,EAAoBM,OAvJC,cAyJlCmR,EAAYoB,YAzJsB,yBA0J/BjX,YAAa6V,EAAYoB,YACzB/M,OAAQ,IACLuO,EAAQ7C,EAAiBnS,SA5JG,IA6J/BxK,SAAUmL,EAAoBM,OA7JC,cA+JlCmR,EAAY9Q,IA/JsB,yBAgK/B/E,YAAa6V,EAAY9Q,IACzBmF,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YAlKG,IAmK/BhL,SAAUmL,EAAoBW,OAnKC,cAsKlC8Q,EAAY+B,WAtKsB,yBAuK/B5X,YAAa6V,EAAY+B,WACzB1N,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SAzKG,IA0K/B7K,SAAUmL,EAAoBa,OA1KC,cA4KlC4Q,EAAY8B,QA5KsB,yBA6K/B3X,YAAa6V,EAAY8B,QACzBzN,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SA/KG,IAgL/B3K,SAAUmL,EAAoBa,OAhLC,cAkLlC4Q,EAAY4B,QAlLsB,yBAmL/BzX,YAAa6V,EAAY4B,QACzBvN,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SArLG,IAsL/B3K,SAAUmL,EAAoBY,OAtLC,cAwLlC6Q,EAAY6B,QAxLsB,yBAyL/B1X,YAAa6V,EAAY6B,QACzBxN,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SA3LG,IA4L/B7K,SAAUmL,EAAoBY,OA5LC,cA8LlC6Q,EAAYgC,QA9LsB,yBA+L/B7X,YAAa6V,EAAYgC,QACzB3N,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SAjMG,IAkM/B3K,SAAUmL,EAAoBG,OAlMC,cAoMlCsR,EAAYiC,QApMsB,yBAqM/B9X,YAAa6V,EAAYiC,QACzB5N,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SAvMG,IAwM/B7K,SAAUmL,EAAoBG,OAxMC,cA0MlCsR,EAAYkC,QA1MsB,yBA2M/B/X,YAAa6V,EAAYkC,QACzB7N,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SA7MG,IA8M/B3K,SAAUmL,EAAoBe,OA9MC,cAgNlC0Q,EAAYmC,QAhNsB,yBAiN/BhY,YAAa6V,EAAYmC,QACzB9N,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SAnNG,IAoN/B7K,SAAUmL,EAAoBe,OApNC,cAsNlC0Q,EAAYoC,QAtNsB,yBAuN/BjY,YAAa6V,EAAYoC,QACzB/N,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SAzNG,IA0N/B3K,SAAUmL,EAAoBgB,OA1NC,cA4NlCyQ,EAAYqC,QA5NsB,yBA6N/BlY,YAAa6V,EAAYqC,QACzBhO,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SA/NG,IAgO/B7K,SAAUmL,EAAoBgB,OAhOC,cAkOlCyQ,EAAYsC,QAlOsB,yBAmO/BnY,YAAa6V,EAAYsC,QACzBjO,OAAQ,IACLuO,EAAQ7C,EAAiBhS,SArOG,IAsO/B3K,SAAUmL,EAAoBiB,OAtOC,cAwOlCwQ,EAAYuC,QAxOsB,yBAyO/BpY,YAAa6V,EAAYuC,QACzBlO,OAAQ,IACLuO,EAAQ7C,EAAiB9R,SA3OG,IA4O/B7K,SAAUmL,EAAoBiB,OA5OC,cA+OlCwQ,EAAYyC,QA/OsB,yBAgP/BtY,YAAa6V,EAAYyC,QACzBpO,OAAQ,IACLuO,EAAQ7C,EAAiB1R,YAlPG,IAmP/BjL,SAAUmL,EAAoBkB,OAnPC,cAqPlCuQ,EAAYwC,OArPsB,yBAsP/BrY,YAAa6V,EAAYwC,OACzBnO,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YAxPG,IAyP/BhL,SAAUmL,EAAoBkB,OAzPC,cA2PlCuQ,EAAYtQ,IA3PsB,yBA4P/BvF,YAAa6V,EAAYtQ,IACzB2E,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YA9PG,IA+P/BhL,SAAUmL,EAAoBmB,OA/PC,cAiQlCsQ,EAAY2C,QAjQsB,yBAkQ/BxY,YAAa6V,EAAY2C,QACzBtO,OAAQ,IACLuO,EAAQ7C,EAAiB1R,YApQG,IAqQ/BjL,SAAUmL,EAAoBoB,OArQC,cAuQlCqQ,EAAY0C,OAvQsB,yBAwQ/BvY,YAAa6V,EAAY0C,OACzBrO,OAAQ,IACLuO,EAAQ7C,EAAiB3R,YA1QG,IA2Q/BhL,SAAUmL,EAAoBoB,OA3QC,cA6QlCqQ,EAAYpQ,IA7QsB,yBA8Q/BzF,YAAa6V,EAAYpQ,IACzByE,OAAQ,IACLuO,EAAQ7C,EAAiB5R,SAhRG,IAiR/B/K,SAAUmL,EAAoBqB,OAjRC,cAmRlCoQ,EAAYnQ,IAnRsB,yBAoR/B1F,YAAa6V,EAAYnQ,IACzBwE,OAAQ,KACLuO,EAAQ7C,EAAiB5R,SAtRG,IAuR/B/K,SAAUmL,EAAoBsB,OAvRC,cAyRlCmQ,EAAY6C,IAzRsB,yBA0R/B1Y,YAAa6V,EAAY6C,IACzBxO,OAAQ,KACLuO,EAAQ7C,EAAiB1R,YA5RG,IA6R/BjL,SAAUmL,EAAoBsU,OA7RC,cA+RlC7C,EAAY8C,QA/RsB,yBAgS/B3Y,YAAa6V,EAAY8C,QACzBzO,OAAQ,KACLuO,EAAQ7C,EAAiB5R,SAlSG,IAmS/B/K,SAAUmL,EAAoBuU,WAnSC,GAuSxB5O,O,gCCxhBA,KACX,KAAM,KAAM,KAAM,KAClB,KAAM,KAAM,KAAM,KAClB,MAAO,KAAM,KAAM,KAAM,KAAM,O,8UCO7BrZ,E,WAaF,WAAYP,GAAmD,IAAlCyoB,EAAiC,uDAAR,KAAQ,maAC1D,YAAAne,KAAA,MAAetK,EASf,YAAAsK,KAAA,kBAA2BrI,KAG3B,YAAAqI,KAAA,MAAkBrK,YAA2C,EAA9B,YAAAqK,KAAA,MAAqB7J,QAGpD,YAAA6J,KAAA,MAAqB,YAAAA,KAAA,MAAqBwN,QAAO,SAAChT,EAAK2C,EAAOR,GAE1D,OADAnC,EAAI2C,GAAgB,EAANR,EACPnC,IACR,IAEH,YAAAwF,KAAA,MAAuB,EAGvB,YAAAA,KAAA,MAA+Bme,EAC/B,YAAAne,KAAA,OAA6B,EAE7BA,KAAKoe,YAAY,KAAM,OAMvBpe,KAAKoe,YAAY,KAAM,OACvBpe,KAAKoe,YAAY,KAAM,O,yCAM3B,WAAe,IAAD,OACV,YAAApe,KAAA,MAAqBkP,SAAQ,SAAC/R,GAC1B9C,QAAQC,IAAR,UAAe6C,EAAf,iBAA6B,EAAKtF,YAAYsF,GAAO9F,SAAS,IAAIoD,SAAS,EAAG,UAElFJ,QAAQC,IAAI,oB,6BAMf,WAAiC,IAAD,OAC7B,OAAO,YAAA0F,KAAA,MAAqBwN,QAAO,SAAC6Q,EAAoBlhB,EAAeR,GAEnE,OADA0hB,EAAKlhB,GAAL,YAAmB,EAAKtF,YAAYsF,GAAO9F,SAAS,IAAIoD,SAAS,EAAG,MAC7D4jB,IACR,M,0BAUP,SAAankB,EAAiBL,GAA2C,IAAD,OAA/BykB,IAA+B,yDAG9DC,EAAazkB,MAAMC,KAAK,CAAC5D,OAAQ0D,IAAI,SAACG,EAAG9D,GAAJ,OACvC,cAAI,GAAJ,GAAaiE,SAASD,EAAUhE,MAClCsE,KAAI,SAAAP,GAAI,kBAASA,EAAK5C,SAAS,IAAIoD,SAAS,EAAG,SAIjD,OADI6jB,GAAOjkB,QAAQC,IAAR,YAAiBJ,EAAQ7C,SAAS,IAAIoD,SAAS,EAAG,KAAlD,aAA2D8jB,EAAWvf,KAAK,OAC/E,YAAAgB,KAAA,MAAawe,UAAUtkB,K,yBAQlC,SAAYiD,GACR,KAAMA,KAAS,YAAA6C,KAAJ,OACP,MAAM,IAAIK,MAAJ,gDAAoDlD,EAApD,MACV,OAAO,YAAA6C,KAAA,MAAgBwe,UAAU,YAAAxe,KAAA,MAAmB7C,M,yBAQxD,SAAYA,EAAe5E,GACvB,KAAM4E,KAAS,YAAA6C,KAAJ,OACP,MAAM,IAAIK,MAAJ,gDAAoDlD,EAApD,MACV,OAAO,YAAA6C,KAAA,MAAgBye,UAAU,YAAAze,KAAA,MAAmB7C,GAAQ5E,K,mBAQhE,WACI,IAAMmmB,EAAyB1e,KAAKnI,YAAY,MAC1C0N,EAAc,YAAAvF,KAAA,MAAa7F,SAASukB,GAE1C,OADA1e,KAAKoe,YAAY,KAAMM,EAAyB,GACzCnZ,I,qBAQX,WACI,IAAMoZ,EAAsB3e,KAAKnI,YAAY,MACvC+mB,EAAW,YAAA5e,KAAA,MAAawe,UAAUG,GAExC,OADA3e,KAAKoe,YAAY,KAAMO,EAAsB,GACtCC,I,2BAQX,WAA0B,OAAQ5e,KAAK6e,QAAU,YAAA7e,KAAA,MAAqB7J,OAAU,I,kBAMhF,SAAKoC,GACD,IAAMumB,EAAY9e,KAAKnI,YAAY,MACnC,YAAAmI,KAAA,MAAaye,UAAUK,EAAWvmB,GAClCyH,KAAKoe,YAAY,KAAMU,EAAY,GACnC,YAAA9e,KAAA,OAAwB,I,iBAO5B,WACI,IAAM+e,EAAkB/e,KAAKnI,YAAY,MAAQ,EAGjD,OAFAmI,KAAKoe,YAAY,KAAMW,GACvB,YAAA/e,KAAA,OAAwB,EACjB,YAAAA,KAAA,MAAawe,UAAUO,K,uBAMlC,WAAmB,IAAD,OAEd,YAAA/e,KAAA,MAAqBkP,SAAQ,SAAC/R,GACtB,CAAC,MAAO,KAAM,MAAMwS,SAASxS,IACjC,EAAKf,KAAK,EAAKvE,YAAYsF,OAG/B6C,KAAK5D,KAAK,YAAA4D,KAAA,MAAuB,GAEjCA,KAAKoe,YAAY,KAAMpe,KAAKnI,YAAY,OACxC,YAAAmI,KAAA,MAAuB,I,sBAO3B,WAAkB,IAAD,OACPgf,EAAsBhf,KAAKnI,YAAY,MAE7CmI,KAAKoe,YAAY,KAAMY,GACvB,YAAAhf,KAAA,MAAuBA,KAAK0H,MAC5B,IAAMuX,EAAc,YAAGjf,KAAH,MAGpB,YAAAA,KAAA,MAAqBM,QAAQ4e,UAAUhQ,SAAQ,SAAC/R,GACxC,CAAC,MAAO,KAAM,MAAMwS,SAASxS,IAEjC,EAAKihB,YAAYjhB,EAAO,EAAKuK,UAIjC,IAAMyX,EAAanf,KAAK0H,MACxB1H,KAAKoe,YAAY,KAAMpe,KAAKnI,YAAY,MAAqB,EAAbsnB,GAGhDnf,KAAKoe,YAAY,KAAMY,EAAsBC,K,6BAQjD,SAAgBvkB,GACZ,IAAM0kB,EAAuB1kB,EAAK,GAIlC,GADmBkS,QAAS,GAAKwS,EAAwBpf,KAAKnI,YAAY,OAC1E,CAGA,IAAMwnB,EAAwB,YAAArf,KAAA,MAAuD,EAAvBof,EACxDE,EAAiB,YAAAtf,KAAA,MAAawe,UAAUa,GAGzC,YAAArf,KAAD,QACAA,KAAK5D,KAAK,GACV4D,KAAKuf,aAGT,YAAAvf,KAAA,OAA6B,EAC7BA,KAAKoe,YAAY,KAAMkB,M,qBAO3B,SAAQ/Z,GACJ,OAAOA,GAEH,KAAK+J,IAAiBiM,WAAW9L,OAE7B,IAAM+P,EAAUxf,KAAKyf,UACfC,EAAc1f,KAAK2f,gBACzB,OAAO,YAAA3f,KAAA,MAAgBye,UAAUiB,EAAaF,GAIlD,KAAKlQ,IAAiBgM,UAAU7L,OAE5B,IAAMmQ,EAAc5f,KAAK2f,gBACnBE,EAAe7f,KAAK2f,gBACpBG,EAAS,YAAA9f,KAAA,MAAgBwe,UAAUoB,GACzC,OAAO,YAAA5f,KAAA,MAAgBye,UAAUoB,EAAcC,GAInD,KAAKxQ,IAAiBmM,WAAWhM,OAE7B,IAAMmQ,EAAc5f,KAAK2f,gBACnBI,EAAa/f,KAAKyf,UAClBlnB,EAAQ,YAAAyH,KAAA,MAAgBwe,UAAUoB,GACxC,OAAO,YAAA5f,KAAA,MAAaye,UAAUsB,EAAYxnB,GAG9C,KAAK+W,IAAiBoM,YAAYjM,OAC9B,IAAMlX,EAASyH,KAAKyf,UACdM,EAAa/f,KAAKyf,UACxB,OAAO,YAAAzf,KAAA,MAAaye,UAAUsB,EAAYxnB,GAI9C,KAAK+W,IAAiBkM,WAAW/L,OAE7B,IAAMsQ,EAAa/f,KAAKyf,UAClBG,EAAc5f,KAAK2f,gBACnBpnB,EAAQ,YAAAyH,KAAA,MAAawe,UAAUuB,GACrC,OAAO,YAAA/f,KAAA,MAAgBye,UAAUmB,EAAarnB,GAIlD,KAAK+W,IAAiBqM,gBAAgBlM,OAClC,IAAMxG,EAAKjJ,KAAK2f,gBACVzW,EAAKlJ,KAAK2f,gBACVK,EAAM,YAAAhgB,KAAA,MAAgBwe,UAAUvV,GAChC1Q,EAAQ,YAAAyH,KAAA,MAAawe,UAAUwB,GACrC,YAAAhgB,KAAA,MAAgBye,UAAUvV,EAAI3Q,GAIlC,KAAK+W,IAAiBsM,gBAAgBnM,OAClC,IAAMwQ,EAAcjgB,KAAKyf,UACnBxW,EAAKjJ,KAAK2f,gBACVzW,EAAKlJ,KAAK2f,gBACVzR,EAAS,YAAAlO,KAAA,MAAgBwe,UAAUvV,GACnC1Q,EAAQ,YAAAyH,KAAA,MAAawe,UAAUyB,EAAc/R,GACnD,OAAO,YAAAlO,KAAA,MAAgBye,UAAUvV,EAAI3Q,GAIzC,KAAK+W,IAAiBuM,UAAUpM,OAE5B,IAAMyQ,EAAKlgB,KAAK2f,gBACVQ,EAAKngB,KAAK2f,gBACVS,EAAiB,YAAApgB,KAAA,MAAgBwe,UAAU0B,GAC3CG,EAAiB,YAAArgB,KAAA,MAAgBwe,UAAU2B,GACjD,OAAOngB,KAAKoe,YAAY,MAAOgC,EAAiBC,GAGpD,KAAK/Q,IAAiBwM,YAAYrM,OAC9B,IAAM+P,EAAUxf,KAAKyf,UACfxW,EAAKjJ,KAAK2f,gBACVW,EAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,GAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,EAAgBd,GAInD,KAAKlQ,IAAiB2M,YAAYxM,OAC9B,IAAM+P,EAAUxf,KAAKyf,UACfxW,EAAKjJ,KAAK2f,gBACVW,EAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,GAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,EAAgBd,GAInD,KAAKlQ,IAAiB0M,YAAYvM,OAC9B,IAAMxG,EAAKjJ,KAAK2f,gBACVrW,EAAMtJ,KAAKyf,UACXa,EAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,GAChD,OAAOjJ,KAAKoe,YAAY,MAAO9U,EAAMgX,GAGzC,KAAKhR,IAAiByM,UAAUtM,OAC5B,IAAMyQ,EAAKlgB,KAAK2f,gBACVQ,EAAKngB,KAAK2f,gBACVS,EAAiB,YAAApgB,KAAA,MAAgBwe,UAAU0B,GAC3CG,EAAiB,YAAArgB,KAAA,MAAgBwe,UAAU2B,GACjD,OAAOngB,KAAKoe,YAAY,MAAOgC,EAAiBC,GAGpD,KAAK/Q,IAAiB6M,YAAY1M,OAC9B,IAAM+P,EAAUxf,KAAKyf,UACfxW,EAAKjJ,KAAK2f,gBACVW,EAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,GAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,EAAgBd,GAInD,KAAKlQ,IAAiB4M,YAAYzM,OAC9B,IAAMyQ,EAAKlgB,KAAK2f,gBACVQ,EAAKngB,KAAK2f,gBACVS,EAAiB,YAAApgB,KAAA,MAAgBwe,UAAU0B,GAC3CG,EAAiB,YAAArgB,KAAA,MAAgBwe,UAAU2B,GACjD,OAAOngB,KAAKoe,YAAY,MAAOgC,EAAiBC,GAGpD,KAAK/Q,IAAiBwN,QAAQrN,OAC1B,IAAMxG,EAAKjJ,KAAK2f,gBACVW,EAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,GAChD,OAAO,YAAAjJ,KAAA,MAAgBye,UAAUxV,EAAIqX,EAAgB,GAGzD,KAAKhR,IAAiByN,QAAQtN,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVW,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAO,YAAAjJ,KAAA,MAAgBye,UAAUxV,GAAIqX,GAAgB,GAIzD,KAAKhR,IAAiBqN,YAAYlN,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVH,GAAUxf,KAAKyf,UACfa,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAO,YAAAjJ,KAAA,MAAgBye,UAAUxV,GAAIqX,IAAiBd,IAG1D,KAAKlQ,IAAiBoN,YAAYjN,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVzW,GAAKlJ,KAAK2f,gBACVY,GAAiB,YAAAvgB,KAAA,MAAgBwe,UAAUvV,IAC3CuX,GAAiB,YAAAxgB,KAAA,MAAgBwe,UAAUtV,IACjD,OAAO,YAAAlJ,KAAA,MAAgBye,UAAUxV,GAAIsX,IAAkBC,IAG3D,KAAKlR,IAAiBuN,YAAYpN,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVH,GAAUxf,KAAKyf,UACfa,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAO,YAAAjJ,KAAA,MAAgBye,UAAUxV,GAAIqX,IAAiBd,IAG1D,KAAKlQ,IAAiBsN,YAAYnN,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVzW,GAAKlJ,KAAK2f,gBACVY,GAAiB,YAAAvgB,KAAA,MAAgBwe,UAAUvV,IAC3CuX,GAAiB,YAAAxgB,KAAA,MAAgBwe,UAAUtV,IACjD,OAAO,YAAAlJ,KAAA,MAAgBye,UAAUxV,GAAIsX,IAAkBC,IAG3D,KAAKlR,IAAiB+M,YAAY5M,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVH,GAAUxf,KAAKyf,UACfa,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,GAAgBd,IAGnD,KAAKlQ,IAAiB8M,YAAY3M,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVzW,GAAKlJ,KAAK2f,gBACVY,GAAiB,YAAAvgB,KAAA,MAAgBwe,UAAUvV,IAC3CuX,GAAiB,YAAAxgB,KAAA,MAAgBwe,UAAUtV,IACjD,OAAOlJ,KAAKoe,YAAY,MAAOmC,GAAiBC,IAGpD,KAAKlR,IAAiBiN,WAAW9M,OAC7B,IAAMxG,GAAKjJ,KAAK2f,gBACVH,GAAUxf,KAAKyf,UACfa,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,GAAgBd,IAGnD,KAAKlQ,IAAiBgN,WAAW7M,OAC7B,IAAMxG,GAAKjJ,KAAK2f,gBACVzW,GAAKlJ,KAAK2f,gBACVY,GAAiB,YAAAvgB,KAAA,MAAgBwe,UAAUvV,IAC3CuX,GAAiB,YAAAxgB,KAAA,MAAgBwe,UAAUtV,IACjD,OAAOlJ,KAAKoe,YAAY,MAAOmC,GAAiBC,IAGpD,KAAKlR,IAAiBmN,YAAYhN,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVH,GAAUxf,KAAKyf,UACfa,GAAgB,YAAAtgB,KAAA,MAAgBwe,UAAUvV,IAChD,OAAOjJ,KAAKoe,YAAY,MAAOkC,GAAgBd,IAGnD,KAAKlQ,IAAiBkN,YAAY/M,OAC9B,IAAMxG,GAAKjJ,KAAK2f,gBACVzW,GAAKlJ,KAAK2f,gBACVY,GAAiB,YAAAvgB,KAAA,MAAgBwe,UAAUvV,IAC3CuX,GAAiB,YAAAxgB,KAAA,MAAgBwe,UAAUtV,IACjD,OAAOlJ,KAAKoe,YAAY,MAAOmC,GAAiBC,IAGpD,KAAKlR,IAAiBhF,IAAImF,OACtB,IAAMxG,GAAKjJ,KAAK2f,gBAKVc,GAAmC,OAJnB,YAAAzgB,KAAA,MAAgBwe,UAAUvV,IAKhD,OAAOjJ,KAAKoe,YAAY,MAAOqC,IAInC,KAAKnR,IAAiB6N,WAAW1N,OAC7B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,KAAYxf,KAAKnI,YAAY,QAC7BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiB4N,QAAQzN,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,KAAUyH,KAAKnI,YAAY,QAC3BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiB2N,QAAQxN,OAC1B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,KAAYxf,KAAKnI,YAAY,QAC7BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiB0N,QAAQvN,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,KAAUyH,KAAKnI,YAAY,QAC3BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiB+N,QAAQ5N,OAC1B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,GAAUxf,KAAKnI,YAAY,QAC3BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiB8N,QAAQ3N,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,GAAQyH,KAAKnI,YAAY,QACzBmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBiO,QAAQ9N,OAC1B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,GAAUxf,KAAKnI,YAAY,QAC3BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBgO,QAAQ7N,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,GAAQyH,KAAKnI,YAAY,QACzBmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBmO,QAAQhO,OAC1B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,IAAWxf,KAAKnI,YAAY,QAC5BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBkO,QAAQ/N,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,IAASyH,KAAKnI,YAAY,QAC1BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBqO,QAAQlO,OAC1B,IAAM+P,GAAUxf,KAAKyf,UACfiB,GAAgB1gB,KAAKyf,UAG3B,YAFID,IAAWxf,KAAKnI,YAAY,QAC5BmI,KAAKoe,YAAY,KAAMsC,KAI/B,KAAKpR,IAAiBoO,QAAQjO,OAC1B,IAAMxG,GAAKjJ,KAAK2f,gBACVpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUvV,IAClCyX,GAAgB1gB,KAAKyf,UAG3B,YAFIlnB,IAASyH,KAAKnI,YAAY,QAC1BmI,KAAKoe,YAAY,KAAMsC,KAK/B,KAAKpR,IAAiBuO,QAAQpO,OAC1B,IAAMlX,GAAQyH,KAAKyf,UACnB,OAAOzf,KAAK5D,KAAK7D,IAIrB,KAAK+W,IAAiBsO,OAAOnO,OACzB,IAAMmQ,GAAc5f,KAAK2f,gBACnBpnB,GAAQ,YAAAyH,KAAA,MAAgBwe,UAAUoB,IACxC,OAAO5f,KAAK5D,KAAK7D,IAIrB,KAAK+W,IAAiBxE,IAAI2E,OACtB,IAAMoQ,GAAe7f,KAAK2f,gBAC1B,OAAO,YAAA3f,KAAA,MAAgBye,UAAUoB,GAAc7f,KAAK0H,OAIxD,KAAK4H,IAAiByO,QAAQtO,OAC1B,IAAMiR,GAAgB1gB,KAAKyf,UAG3B,OAFAzf,KAAKuf,YAEEvf,KAAKoe,YAAY,KAAMsC,IAIjC,KAAKpR,IAAiBwO,OAAOrO,OAC1B,IAAMiQ,GAAc1f,KAAK2f,gBACnBe,GAAgB,YAAA1gB,KAAA,MAAgBwe,UAAUkB,IAGhD,OAFA1f,KAAKuf,YAEEvf,KAAKoe,YAAY,KAAMsC,IAIlC,KAAKpR,IAAiBtE,IAAIyE,OACtB,OAAOzP,KAAK2gB,WAGjB,KAAKrR,IAAiBrE,IAAIwE,OACtB,OAAO,EAGX,KAAKH,IAAiB2O,IAAIxO,OACtB,IAAMmR,GAAc5gB,KAAKyf,UACzB,OAAOzf,KAAK6gB,gBAAgBD,IAGhC,KAAKtR,IAAiB4O,QAAQzO,OAC1B,YAAAzP,KAAA,OAA6B,EAC7BA,KAAK2gB,c,mBAQhB,WAA0B,OAAO3gB,KAAK8gB,QAAQ9gB,KAAK6e,W,iBAEnD,WAAO,IAAD,OACW7e,KAAK7I,SAGd4pB,GAAa,kBAAM,EAAKjS,a,KAKrB7Y,Q,gEC5nBf,kCACO,IAAMN,EAAe,SAACqrB,GAEzB,IAAMC,EAAK,IAAIC,YAAYF,GAE3B,OADW,IAAItoB,SAASuoB,M","file":"static/js/main.4e277fbd.chunk.js","sourcesContent":["import { createSlice, createSelector, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport type { RootState } from \"../store\";\r\nimport { init, VM } from \"../harmonic\";\r\nimport { Memory } from \"../harmonic/src/types\";\r\nimport CPU from \"../harmonic/src/cpu/CPU\";\r\n\r\n// Initializes the machine\r\nlet vm: VM;\r\nexport const initVM = (program: Uint8Array, base: number = 0, previousMemory: Uint8Array = null) => {\r\n    vm = init(program, base, previousMemory);\r\n};\r\n\r\n// State type\r\ninterface MemoryState {\r\n    memory: Memory,\r\n    cpu: CPU,\r\n    meta: any,\r\n    writableBytes: Uint8Array,\r\n    halt: boolean\r\n}\r\n\r\ninitVM(new Uint8Array([]));\r\nconst initialState: MemoryState = {\r\n    memory: vm.memory,\r\n    cpu: vm.cpu,\r\n    meta: null,\r\n    writableBytes: vm.writableBytes,\r\n    halt: false\r\n}\r\n\r\nexport const memoryReducer = createSlice({\r\n    name: 'memory',\r\n    initialState,\r\n    reducers: {\r\n        // Initialization\r\n        initMachine: (state, action: PayloadAction<{program: number[], base: number, reset?: boolean}>) => {\r\n            const { program, base, reset } = action.payload;\r\n            initVM(new Uint8Array(program), base, reset ? null :state.writableBytes);\r\n\r\n            return {\r\n                ...state,\r\n                ...vm\r\n            }\r\n        },\r\n        // Execute and step through instruction\r\n        step: (state) => {\r\n            const halt = vm.cpu.cycle();\r\n\r\n            // console.log(vm.cpu.getRegister('pc'));\r\n            return {\r\n                ...state,\r\n                ...vm, \r\n                halt: halt || false\r\n            }\r\n        },\r\n        // Sets up metadata corresponding to parsed assembly\r\n        setMeta: (state, action: PayloadAction<{meta: any, base: number, reset: boolean}>) => {\r\n            const {meta, base, reset} = action.payload;\r\n\r\n            return {\r\n                ...state,\r\n                meta: reset ? {[base.toString(16)]: [...meta] } : {...state.meta,  [base.toString(16)]: [...meta] }\r\n            }\r\n        },\r\n\r\n        resetHalt: (state) => {\r\n            return {\r\n                ...state,\r\n                halt: false\r\n            }\r\n        }\r\n    }\r\n})\r\n\r\nexport const { step, initMachine, setMeta, resetHalt } = memoryReducer.actions;\r\n\r\n/** Selectors **/\r\nexport const registersSelector = createSelector(\r\n    (state: RootState) => state.memory.cpu.getRegisterBank(),\r\n    (registers: any) => {\r\n        return registers;\r\n    }\r\n);\r\n\r\nexport const pcSelector = createSelector(\r\n    (state: RootState) => state.memory.cpu.getRegister('pc'),\r\n    (pc: number) => {\r\n        return pc;\r\n    }\r\n);\r\n\r\nexport const spSelector = createSelector(\r\n    (state: RootState) => state.memory.cpu.getRegister('sp'),\r\n    (sp: number) => {\r\n        return sp;\r\n    }\r\n);\r\n\r\nexport const metaSelector = createSelector(\r\n    (state: RootState) => state.memory.meta,\r\n    (meta: any) => {  \r\n        return meta;\r\n    }\r\n);\r\n\r\nexport const haltSelector = createSelector(\r\n    (state: RootState) => state.memory.halt,\r\n    (halt: boolean) => {  \r\n        return halt;\r\n    }\r\n);\r\n\r\nexport const memorySelector = createSelector(\r\n    (state: RootState) => state.memory.memory,\r\n    (memory: Memory) => {  \r\n        return memory;\r\n    }\r\n);\r\n\r\nexport default memoryReducer.reducer;\r\n","import { createMemory } from './src/cpu/createMemory';\r\nimport  CPU  from './src/cpu/CPU';\r\nimport { Memory } from \"./src/types\";\r\n/* IO / display code - not used right now */\r\n// import MemoryMapper from './src/cpu/MemoryMapper';\r\n// import * as readline from 'readline';\r\n// import { createScreenDevice } from './src/cpu/screenDevice';\r\n// import { screenDeviceProgram } from './src/cpu/programs';\r\n\r\n// VM Initialization and Program Loading \r\nexport interface VM { memory: Memory, writableBytes: Uint8Array, cpu: CPU };\r\nexport const init = (program: Uint8Array = null, base: number, previousMemory: Uint8Array): VM => {\r\n    const memory = createMemory(256 * 256);                 // Create memory - 16-bit VM : 65536 words\r\n    const writableBytes = new Uint8Array(memory.buffer);\r\n    if (previousMemory) writableBytes.set(previousMemory);\r\n    const cpu = new CPU(memory);\r\n\r\n    // Store the program machine code in memory\r\n    // -> We have to do it this way since React's\r\n    // state is immutable.\r\n    for (let i = 0; program && i < program.length; i++) {\r\n        writableBytes[base + i] = program[i];\r\n    }\r\n\r\n    return { memory, writableBytes, cpu };\r\n}\r\n\r\n\r\n/* Old test code\r\n\r\n// 2^16 8-bit words\r\nconst memory = createMemory(65536);\r\nconst writableBytes = new Uint8Array(memory.buffer); // Each cell is a byte\r\n\r\n//Create cpu.\r\nconst memoryMapper = new MemoryMapper();\r\nconst cpu = new CPU(memoryMapper);\r\n\r\n// Map the entire address space\r\nmemoryMapper.map(memory, 0x0000, 0xffff);\r\n\r\n// Map 256 B of address space to screen device;\r\n// Remaps to 0 to ff\r\nmemoryMapper.map(createScreenDevice(), 0x3000, 0x30ff, true);\r\n\r\n// Create instruction set \r\n\r\n// Load program to count to three in Mmem.\r\nscreenDeviceProgram(writableBytes);\r\n\r\ncpu.run();\r\n\r\nRun the program.\r\ncpu.viewMemoryAt(cpu.getRegister('pc'), 8); // next instruction(s)\r\ncpu.viewMemoryAt(0xffff - 43, 44);\r\n\r\n// Setup node readline to step through and see each instruction cycle\r\n\r\nSet readline to recognize cmd input and provide output.\r\nconst rl = readline.createInterface({\r\n    input: process.stdin,\r\n    output: process.stdout,\r\n});\r\n\r\n// Create a 'newline' event. On event, step.\r\nrl.on('line', () => {\r\n    cpu.cycle();\r\n    //cpu.debug();\r\n    //cpu.viewMemoryAt(cpu.getRegister('pc'), 8); // next instruction(s)\r\n    //cpu.viewMemoryAt(0xffff - 43, 44);\r\n});\r\n\r\n*/\r\n\r\n","import { inspect } from \"util\";\r\n\r\n// Parser Node Types \r\nenum ParserTypes {\r\n    REGISTER=\"REGISTER\",\r\n    HEX_LITERAL=\"HEX_LITERAL\",\r\n    VARIABLE=\"VARIABLE\",\r\n    ADDRESS=\"ADDRESS\",\r\n\r\n    OP_PLUS=\"OP_PLUS\",\r\n    OP_MINUS=\"OP_MINUS\",\r\n    OP_MULTIPLY=\"OP_MULTIPLY\",\r\n\r\n    BINARY_OPERATION=\"BINARY_OPERATION\",\r\n    BRACKETED_EXPRESSION=\"BRACKETED_EXPRESSION\",\r\n    SQUARE_BRACKETED_EXPRESSION=\"SQUARE_BRACKETED_EXPRESSION\",\r\n\r\n    LABEL=\"LABEL\",\r\n    INSTRUCTION=\"INSTRUCTION\",\r\n\r\n    DATA=\"DATA\",\r\n    CONSTANT=\"CONSTANT\",\r\n    STRUCTURE=\"STRUCTURE\",\r\n    INTERPRET_AS=\"INTERPRET_AS\"\r\n};\r\ntype ParseReturn = {\r\n    type: ParserTypes;\r\n    value: any;\r\n};\r\n\r\n/**\r\n * Creates a deeplog of the specified element\r\n * (used to print all nested levels of an object).\r\n * @param x any, the item to log.\r\n */\r\nconst deepLog = (x: any) => console.log(inspect(x, {\r\n    depth: Infinity,\r\n    colors: true\r\n}));\r\n\r\n/**\r\n * Returns the last element in the specified array.\r\n * @param arr, the array.\r\n */\r\nconst last = (arr: any[]) => arr[arr.length - 1];\r\n\r\n/*** Utility parsers ***/\r\n/**\r\n * Maps a nodes value with the specfied type.\r\n * @param type, the type to associate.\r\n * @returns ParseReturn, the mapped node.\r\n */\r\nconst asType = (type: ParserTypes) => (value: any): ParseReturn => ({ type, value });\r\n\r\n/**\r\n * Joins the parsed values supplied by the specified parser.\r\n * @param parser Parser, the parser to match.\r\n * @returns the joined values.\r\n */\r\nconst mapJoin = parser => parser.map(items => items.join(\"\"));\r\n\r\n/**\r\n * Recursively types the operations in a bracketed expression.\r\n * @param expr, the expression to typify.\r\n * @returns ParseReturn, the typified expression node.\r\n */\r\nconst typifyBracketedExpression = (expr: any): ParseReturn => {\r\n    const asBracketed = asType(ParserTypes.BRACKETED_EXPRESSION);\r\n    return asBracketed(expr.map(element => {\r\n        if (Array.isArray(element)) {\r\n            return typifyBracketedExpression(element);\r\n        }\r\n        return element;\r\n    }));\r\n}\r\n\r\nexport {\r\n    ParserTypes,\r\n\r\n    deepLog,\r\n    last,\r\n\r\n    asType, \r\n    mapJoin, \r\n    typifyBracketedExpression\r\n};\r\n","import { configureStore, createSerializableStateInvariantMiddleware, isPlain } from \"@reduxjs/toolkit\";\r\nimport { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\r\nimport CPU from \"./harmonic/src/cpu/CPU\";\r\nimport memoryReducer from \"./reducers/memoryReducer\";\r\n\r\n// Not Recommended: Override the toolkit serializable check\r\n// since typed arrays are not serializable. However, we need them to properly \r\n// interpret the stored data as unsigned 8-bit values.\r\nconst isTypedArrayOrCPU = (value: any) => {\r\n    if (!value || !(typeof value === \"object\")) { return false; }\r\n    const isDataView = (value.constructor === DataView);\r\n    const isUint8Array = (value.constructor === Uint8Array);\r\n    const isCPU = (value.constructor === CPU);\r\n    return isDataView || isUint8Array || isCPU;\r\n};\r\n\r\n// Augment middleware to consider typed array buffers and CPU class as serializable\r\nconst isSerializable = (value: any) => isTypedArrayOrCPU(value) || isPlain(value)\r\nconst serializableMiddleware = createSerializableStateInvariantMiddleware({\r\n  isSerializable,\r\n})\r\n\r\n// State (Main Memory)\r\nexport const store = configureStore({\r\n    reducer: {\r\n        memory: memoryReducer,\r\n    },\r\n    middleware: [serializableMiddleware]\r\n});\r\n\r\n// Inferred Types\r\nexport type RootState = ReturnType<typeof store.getState>;\r\nexport type AppDispatch = typeof store.dispatch;\r\n\r\n// Hooks\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;","import { extendTheme, ThemeConfig } from \"@chakra-ui/react\";\r\n\r\nconst config: ThemeConfig = {\r\n    initialColorMode: \"dark\",\r\n    useSystemColorMode: true\r\n}\r\n\r\nconst theme = extendTheme({ config });\r\nexport default theme;","import { Table, Tbody, Td, Th, Thead, Tr } from \"@chakra-ui/table\";\r\nimport React, { forwardRef, useEffect, useImperativeHandle, useState } from \"react\";\r\nimport { Memory } from \"../harmonic/src/types\";\r\nimport { memorySelector, pcSelector, spSelector } from \"../reducers/memoryReducer\";\r\nimport { useAppSelector } from \"../store\";\r\nimport './memoryStyles.css';\r\n\r\n/*\r\nStart 0x00\r\n0x0000    -- -- -- --\r\n0x0004    -- -- -- --\r\n0x0008    -- -- -- -- \r\n0x000C    -- -- -- -- \r\n0x0010    -- -- -- -- \r\n*/\r\n\r\n// Maximum 16 bit address\r\nconst MAX_ADDRESS = 0xffff;\r\n\r\n/**\r\n * Gets next n bytes (row) of memory contents from the specified base address. \r\n * @param memory Memory, the vm's memory.\r\n * @param n number, the number of bytes in the row.\r\n * @param base number, the base address.\r\n * @returns the next n bytes.\r\n */\r\ntype Byte = { byte: string; id: string; };\r\nconst getMemoryRow = (memory: Memory, n: number, base: number): Byte[] => {\r\n    const nextNBytes = Array.from({length: n}, (_, i) => {                      // Create an array of value, address pairs\r\n        const address = base + i;\r\n        let byte: number;\r\n        try {\r\n            byte = memory.getUint8(address)\r\n        } catch (e) {\r\n            console.log(e.msg);\r\n            byte = MAX_ADDRESS;\r\n        }\r\n        return { byte, address }\r\n    }).map(({ byte, address }) => {                                             // And map it to an array of formatted value, id pairs\r\n        const formattedByte =                                                   // id is simply mmem-address for css targetting\r\n            address <= MAX_ADDRESS ?\r\n            byte ? `0x${byte.toString(16).padStart(2, '0')}\\t` : `0x00\\t`\r\n            :\r\n            ``\r\n        const byteID = `mmem-${address}`;\r\n\r\n        return { byte: formattedByte, id: byteID };\r\n    });\r\n\r\n    return nextNBytes;\r\n}\r\n\r\n/**\r\n * A table view of main memory\r\n * @param props MainMemoryProps, end is the max address. Caption is the table name (unused now). \r\n * @param ref, forward ref to set base address externally (bad, yes).\r\n * @returns JSX.Element, the main memory component.\r\n */\r\ntype MainMemoryProps = { end?: number, tableCaption?: string };\r\nconst MainMemory = ({ end, tableCaption }: MainMemoryProps, ref) => {\r\n    const memory = useAppSelector(memorySelector);      // The memory bank in state \r\n    const pc = useAppSelector(pcSelector);              // The program counter in state\r\n    const sp = useAppSelector(spSelector);              // The stack pointer in state\r\n    const rows = 7;                                     // Maximum amount of rows\r\n    const cols = 4;                                     // Maximum amount of columns\r\n    \r\n    /**\r\n     * Acquires the base address based on the end address and \r\n     * amount of cells.\r\n     * @returns \r\n     */\r\n    const getBase = () => {\r\n        if (end) {\r\n            return (end - rows * cols);     // end specified: base is end - num_cells\r\n        }\r\n\r\n        return Math.floor(pc / (rows * cols)) * (rows * cols);  // default to beginning of page containing pc (floor remainder * num_cells)\r\n    }\r\n    const [base, setBase] = useState(getBase());                // Base, defaults to above\r\n\r\n    // If pc ever changes, update getBase (for continual running / step)\r\n    useEffect(() => {\r\n        setBase(getBase())\r\n    }, [pc])\r\n\r\n    const memoryTable = (base: number, rows: number, columns: number) => {\r\n        const memoryRows = [] as any[];                                                 // Stores the values in memory for each table row\r\n\r\n        for (let i = base; i < base + rows * columns && i < 0xffff; i += columns) {     // Fill the table rows\r\n            memoryRows.push(getMemoryRow(memory, columns, i));\r\n        }\r\n\r\n        return (\r\n            <Table size=\"sm\" height=\"89%\" variant=\"striped\" colorScheme=\"twitter\" marginBottom={\"5px\"}>\r\n                <Thead>\r\n                    <Tr>\r\n                        <Th>Address</Th>\r\n                    </Tr>\r\n                </Thead>\r\n                <Tbody>\r\n                    \r\n                    { memoryRows.map((row, idx) => (                                    // Format table rows into table\r\n                        <Tr>\r\n                            <Th>{ `0x${(base + idx * columns).toString(16).padStart(4, '0')}:\\t` }</Th>\r\n                                { row.map(({byte, id}) => (\r\n                                    <Td className={ id }>{ byte }</Td>\r\n                                ))\r\n                                }\r\n                        </Tr>\r\n                    ))\r\n                    }\r\n                </Tbody>\r\n            </Table>\r\n        )\r\n    }\r\n\r\n    /**\r\n     * UseEffect to highlight the cells pointed at by pc and sp.\r\n     */\r\n    useEffect(() => {\r\n        const pcCell = document.getElementsByClassName(`mmem-${pc}`);\r\n        const spCell = document.getElementsByClassName(`mmem-${sp}`);\r\n\r\n        let pcElem;\r\n        let spElem;\r\n\r\n        // Add a class to target in css\r\n        if (pcCell[0]) {\r\n            pcElem = pcCell[0];\r\n            pcElem.classList.add('pointed-pc');\r\n        }\r\n        if (spCell[0]) {\r\n            spElem = spCell[0];\r\n            spElem.classList.add('pointed-sp');\r\n        }\r\n\r\n        // Before calling the next useEffect, clear the classes.\r\n        return () => {\r\n            pcElem?.classList.remove('pointed-pc');\r\n            spElem?.classList.remove('pointed-sp');\r\n        }\r\n    })\r\n\r\n    // Protectively set the base value -> if invalid, default to setBase.\r\n    const setBaseWrapped = (value: number) => {\r\n        isNaN(value) ? setBase(getBase()) : setBase(value);\r\n    }\r\n\r\n    // Forward setBase to be set externally via input in ProgramTables.\r\n    useImperativeHandle(ref, () => ({\r\n        setBaseWrapped (value: number) {\r\n            setBaseWrapped(value);\r\n        }\r\n    }), []);\r\n\r\n    return (\r\n      memoryTable(base, rows, cols)\r\n    );\r\n  }\r\n\r\n  export default forwardRef(MainMemory);\r\n","import { Table, Tbody, Td, Th, Thead, Tr } from \"@chakra-ui/table\";\r\nimport React from \"react\";\r\nimport { registersSelector } from \"../reducers/memoryReducer\";\r\nimport { useAppSelector } from \"../store\";\r\n\r\n/**\r\n * View of vm registers.\r\n */\r\nconst Registers = () => {\r\n    const registers = useAppSelector(registersSelector);  // The registers\r\n  \r\n    // Map each register into the table.\r\n    const registerTable = Object.keys(registers).map((label, idx) => (\r\n      <Tr key={ idx }>\r\n        <Th style={{ color: (label === \"pc\") ? \"rgba(165, 245, 191, 0.9)\" : (label === \"sp\") ? \"rgba(216, 165, 245, 0.9)\" : \"inherit\" }}>{ label }</Th>\r\n        <Td >{ registers[label] }</Td>\r\n      </Tr>\r\n    ))\r\n\r\n    return (\r\n      <Table size=\"sm\" height=\"94.6%\" variant=\"striped\" colorScheme=\"twitter\">\r\n        <Thead>\r\n          <Tr>\r\n            <Th>Register</Th>\r\n            <Th isNumeric>Contents</Th>\r\n          </Tr>\r\n        </Thead>\r\n        <Tbody>\r\n          { registerTable }\r\n        </Tbody>\r\n      </Table>\r\n    );\r\n  }\r\n\r\n  export default Registers;","import React from \"react\";\r\nimport { spSelector } from \"../reducers/memoryReducer\";\r\nimport { useAppSelector } from \"../store\";\r\nimport MainMemory from \"./Memory\";\r\n\r\n/**\r\n * A view for the stack. Same as memory view but using\r\n * a different pointer.\r\n */\r\nconst Stack = () => {\r\n    const sp = useAppSelector(spSelector);\r\n    return <MainMemory end={sp + 2} tableCaption=\"Stack\"/>\r\n}\r\n\r\nexport default Stack;","import { Heading } from \"@chakra-ui/layout\";\r\nimport { Input } from \"@chakra-ui/react\";\r\nimport React, { useRef } from \"react\";\r\nimport MainMemory from \"./Memory\";\r\nimport Registers from \"./Registers\";\r\nimport Stack from \"./Stack\";\r\n\r\n/**\r\n * View of all program tables: registers, main memory (indexed at a specified pointer) and stack.\r\n * @returns JSX.Element, the program tables component.\r\n */\r\nconst ProgramTables = () => {\r\n    const memoryRef = useRef<any>();    // Forward ref into main memory to set base pointer \r\n                                        // from external label (so it can be beside the heading - yea it's bad :P)\r\n\r\n    return(\r\n    <div className=\"program-wrapper\">\r\n        <div className=\"registers\">\r\n            <Heading>Registers</Heading>\r\n            <Registers />\r\n        </div>\r\n        <div className=\"memory-col\">\r\n            <div style={{display: \"block\", minHeight: \"305px\"}}>\r\n                <div className=\"memory-head\">\r\n                    <Heading>Main Memory</Heading>\r\n                    <Input \r\n                        defaultValue={\"0000\"}\r\n                        color={\"blue.600\"}\r\n                        fontWeight={\"bold\"} \r\n                        maxLength={4} \r\n                        width={\"60px\"}\r\n                        fontSize={\"18px\"} \r\n                        padding={\"5px\"}\r\n                        onChange={event => {    // Update the base pointer\r\n                            memoryRef.current && memoryRef.current.setBaseWrapped(parseInt(event.target.value, 16))\r\n                        }}\r\n                    >\r\n                    </Input>\r\n                </div>  \r\n                <MainMemory ref={memoryRef}/>\r\n            </div>\r\n            <div className=\"stack\">\r\n                <Heading>Stack</Heading>\r\n                <Stack />\r\n            </div>\r\n        </div>\r\n    </div>\r\n    );\r\n};\r\n\r\nexport default ProgramTables;","import Arc from \"../../parser/arc/index\";\r\nimport { Parser as IParser } from \"../../parser/arc/index\";\r\nimport { Instruction, InstructionMnemonic } from \"../../../cpu/instructions\";\r\nimport { address, hexLiteral, register, upperOrLowerStr } from \"../common\";\r\nimport { squareBracketExpr } from \"../expressions\";\r\nimport { parserTypes } from \"../parserTypes\";\r\nimport { ParserTypes } from \"../util\";\r\n\r\n/* Types */\r\nexport interface IReturn  { type: ParserTypes; value: any; }                                        // Parser return value types\r\ntype Parser = IParser<IReturn, string>;                                                             // Generic Parser\r\nconst contextual = (arg: () => Generator<any, IReturn, any>) => Arc.contextual<IReturn>(arg);       // Contextual Typecast\r\n\r\n/**\r\n * Matches and wraps a literal + register instruction of the form\r\n * MNEMONIC ${LITERAL}, REGISTER \r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst litReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);        // Match the mnemonic\r\n    yield Arc.whitespace;                   // Must be followed by whitespace\r\n\r\n    const arg1 = yield Arc.choice([         // Match the literal (can be an expression)\r\n        hexLiteral,\r\n        squareBracketExpr\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;           // Match comma\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const arg2 = yield register;            // Match the register, followed by any whitespace/commas\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({        // Return the wrapped instruction\r\n        instruction: type,\r\n        args: [arg1, arg2]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a register + literal instruction of the form\r\n * MNEMONIC REGISTER, ${LITERAL} \r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst regLit = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const arg1 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const arg2 = yield Arc.choice([\r\n        hexLiteral,\r\n        squareBracketExpr\r\n    ]);\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [arg1, arg2]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a register + register instruction of the form\r\n * MNEMONIC REGISTER, REGISTER\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst regReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const r1 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const r2 = yield register;\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [r1, r2]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a register + address instruction of the form\r\n * MNEMONIC REGISTER, &[MEMORY ADDRESS]\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst regMem = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const r1 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    // &4 or &[...]\r\n    const addr = yield Arc.choice([\r\n        address,\r\n        Arc.char('&').chain(() => squareBracketExpr)\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [r1, addr]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps an address + literal instruction of the form\r\n * MNEMONIC &[MEMORY ADDRESS], REGISTER\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst memReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    // &4 or &[...]\r\n    const addr = yield Arc.choice([\r\n        address,\r\n        Arc.char('&').chain(() => squareBracketExpr)\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const r1 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [addr, r1]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a literal + adress instruction of the form\r\n * MNEMONIC ${LITERAL}, &[MEMORY ADDRESS]\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst litMem = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const lit = yield Arc.choice([\r\n        hexLiteral,\r\n        squareBracketExpr\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    const addr = yield Arc.choice([\r\n        address,\r\n        Arc.char('&').chain(() => squareBracketExpr)\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [lit, addr]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a register + register (as memory index) instruction of the form\r\n * MNEMONIC &REGISTER, REGISTER\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst regIndReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const r1 = yield Arc.char('&').chain(() => register);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const r2 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [r1, r2]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a literal + register + register instruction of the form\r\n * MNEMONIC ${LITERAL} , &REGISTER, REGISTER\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst litOffReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const lit = yield Arc.choice([\r\n        hexLiteral,\r\n        squareBracketExpr\r\n    ]);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const r1 = yield Arc.char('&').chain(() => register);\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char(',');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const r2 = yield register;\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [lit, r1, r2]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps an instruction with no arguments of the form\r\n * MNEMONIC\r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst noArgs = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: []\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a single register instruction of the form\r\n * MNEMONIC REGISTER \r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst singleReg = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const r1 = yield register;\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [r1]\r\n    });\r\n});\r\n\r\n/**\r\n * Matches and wraps a single  literal instruction of the form\r\n * MNEMONIC ${LITERAL} \r\n * for the specified instruction type.\r\n * @param mnemonic InstructionMnemonic, the instruction mnemonic.\r\n * @param type Instruction, the specific instruction type to wrap.\r\n * @returns Parser, the wrapped litReg parser.\r\n */\r\nconst singleLit = (mnemonic: InstructionMnemonic, type: Instruction): Parser => contextual(function* () {\r\n    yield upperOrLowerStr(mnemonic);\r\n    yield Arc.whitespace;\r\n\r\n    const lit = yield Arc.choice([\r\n        hexLiteral,\r\n        squareBracketExpr\r\n    ]);\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.optionalComment;\r\n\r\n    return parserTypes.instruction({\r\n        instruction: type,\r\n        args: [lit]\r\n    });\r\n});\r\n\r\nexport {\r\n    litReg,\r\n    regLit,\r\n    regReg,\r\n    regMem,\r\n    memReg,\r\n    litMem,\r\n    regIndReg,\r\n    litOffReg,\r\n    noArgs,\r\n    singleReg,\r\n    singleLit\r\n}\r\n","import { mapJoin } from \"../util\";\r\nimport { \r\n    Err,\r\n    Mutator, \r\n    NonNull, \r\n    Ok, \r\n    ParserState, \r\n    ParserStateTransformer \r\n} from \"./types\";\r\ntype Selector<T, E = string> = (result: any) => Parser<T, E>;\r\ntype ParserThunk<T, E = string> = () => Parser<T, E>;\r\n\r\n/*** ParserState update helpers ***/\r\n/**\r\n * Updates the specified parser state with a new result and index, if specified.\r\n * @param state ParserState, the parser state to be updated.\r\n * @param result NonNull, the parser result.\r\n * @param index number<Optional>, the new index pertaining to the new state.\r\n * @returns ParserState, the updated parser state.\r\n */\r\nconst updateParserState = <T>(state: ParserState<T, any>, result: T, index?: number): Ok<T> => (\r\n    index ? { ...state, index, result, isError: false, error: null } : { ...state, result,  isError: false, error: null }\r\n);\r\n\r\n/**\r\n * Updates the specified parser state with the specified error.\r\n * @param state ParserState, the parser state to be updated.\r\n * @param errorMsg string, the error message.\r\n * @returns ParserState, the updated parser state.\r\n */\r\nconst updateParserError = <T, E>(state: ParserState<T, any>, errorMsg: E): Err<E> => ({\r\n    ...state,\r\n    isError: true,\r\n    result: null,\r\n    error: errorMsg\r\n});\r\n\r\n/**\r\n * A parser interface that supports transforming a specified input\r\n * string subject to the supplied parsing rules in a state transformer.\r\n */\r\nclass Parser<T, E = string> {\r\n    #parserStateTransformer: ParserStateTransformer<T, E>;\r\n\r\n    /**\r\n     * Create a new parser.\r\n     * @param parserStateTransformer ParserStateTransformer, function that\r\n     * specifies the rules for parsing the target, accepting a parsing state and \r\n     * returns the resulting transformed state.\r\n     */\r\n    constructor(parserStateTransformer: ParserStateTransformer<T, E>) {\r\n        this.#parserStateTransformer = parserStateTransformer;\r\n    }\r\n\r\n    /**\r\n     * Transform the supplied state subject to the state transformer.\r\n     * @param parserState ParserState, the parser state to transform.\r\n     * @returns ParserState, the transformed parser state.\r\n     */\r\n    parse(parserState: ParserState<any, any>): ParserState<T, E> { \r\n        return this.#parserStateTransformer(parserState);\r\n    }\r\n\r\n    /**\r\n     * Parse the supplied target string subject to the state transformer.\r\n     * @param targetString string, the string to parse.\r\n     * @returns ParserState, the state following the parsing of the supplied string.\r\n     */\r\n    run(targetString: string, strict: boolean = true): ParserState<T, E> {\r\n        const initialState = {\r\n            targetString,\r\n            index: 0,\r\n            result: null,\r\n            isError: false,\r\n            error: null\r\n        }\r\n        \r\n        const finalParsed = this.#parserStateTransformer(initialState);\r\n        if (strict && finalParsed.index != finalParsed.targetString.length) {\r\n                throw new Error(`Syntax error: index ${finalParsed.index}: ` +\r\n                    `${finalParsed.targetString.slice(finalParsed.index, Math.min(finalParsed.index + 15, finalParsed.targetString.length))} ...`);\r\n        }\r\n        return finalParsed;\r\n    }\r\n\r\n    //TODO: Solve mapping types\r\n    /**\r\n     * Defines a new parser that maps this parser's result to another\r\n     * subject to the supplied mutator.\r\n     * @param mutator Mutator, function that maps the result of a given state\r\n     * to another.\r\n     * @returns Parser, a wrapped mutator parser.\r\n     */\r\n    map<K>(mutator: Mutator<T, K>): Parser<K, E> {\r\n            // @ts-ignore\r\n        return new Parser(parserState => {\r\n            // @ts-ignore\r\n            const nextState = this.#parserStateTransformer(parserState);\r\n\r\n            // Mutate state result if there is no error.\r\n            if (nextState.isError) return nextState;\r\n            // @ts-ignore\r\n            return updateParserState<K>(nextState, mutator(nextState.result));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Defines a new parser using the result of a selector function. The selector\r\n     * accepts the result of another parser and, from it, selects the next parser to apply conditionally.\r\n     * @param selector Selector, function that conditionally returns a parser based on some supplied result.\r\n     * @returns Parser, the next parser.\r\n     */\r\n    chain(selector: Selector<any, any>): Parser<any, any> {\r\n        return new Parser(parserState => {\r\n            const nextState = this.#parserStateTransformer(parserState);\r\n\r\n            // Don't chain if there is an error.\r\n            if (nextState.isError) return nextState;\r\n\r\n            const nextParser = selector(nextState.result);\r\n            return nextParser.parse(nextState);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * A string lexer. Tokenizes the specified string.\r\n * @param s string, the string to tokenize.\r\n * @returns ParserState, the state following parsing completion.\r\n */\r\nconst str = (s: string) => new Parser((parserState: ParserState<string>) => {\r\n    const { targetString, index, isError } = parserState;\r\n    \r\n    // Propogate the error if there is one.\r\n    if (isError) { return parserState; }\r\n\r\n    // Slice the target to the current index\r\n    const slicedTarget = targetString.slice(index);\r\n    if (slicedTarget.length === 0) {\r\n        return updateParserError(parserState, `str: Tried to match \"${s}\" but got unexpected end of input.`)\r\n    }\r\n\r\n    // Check that our search string is next in the target\r\n    if (slicedTarget.startsWith(s)){\r\n        // Success\r\n        return updateParserState(parserState, s, index + s.length);\r\n    }\r\n\r\n    return updateParserError(parserState, `str: Tried to match ${s} but got ${targetString.slice(index, index + 10)}...`);\r\n});\r\n\r\n/**\r\n * A character lexer. Tokenizes the specified character.\r\n * @param c string, the character to tokenize.\r\n * @returns ParserState, the updated state.\r\n */\r\nconst char = (c: string): Parser<string> => {\r\n    if (!c || c.length !== 1) {\r\n      throw new TypeError(\r\n        `char must be called with a single character, but got ${c}`,\r\n      );\r\n    }\r\n  \r\n    return new Parser(parserState => {\r\n        if (parserState.isError) return parserState;\r\n  \r\n        const { targetString, index } = parserState;\r\n\r\n        if (targetString.length === 0) {\r\n            return updateParserError(\r\n                parserState,\r\n                `ParseError (position ${index}): Expecting character '${c}', but got end of input.`,\r\n                );\r\n        }\r\n\r\n        const char = targetString.charAt(index)\r\n        return char === c ? \r\n            updateParserState(parserState, c, index + 1)\r\n            : \r\n            updateParserError(\r\n                parserState,\r\n                `ParseError (position ${index}): Expecting character '${c}', got '${char}'`,\r\n            );\r\n    });\r\n};\r\n\r\n/*** Parser Combinators ***/\r\n/**\r\n * Defines a new parser that parses a target subject to the supplied\r\n * sequence of parsers in the specified order.\r\n * @param parsers Parser[], an array of parsers to define a parsing sequence \r\n * for the new parser.\r\n * @returns Parser, the sequence parser.\r\n */\r\nconst sequenceOf = (parsers: Parser<any>[]) => new Parser((parserState: ParserState<any[]>) => {\r\n    if (parserState.isError) { return parserState; }\r\n\r\n    const results = [] as NonNull[];\r\n    let nextState = parserState;\r\n\r\n    // Attempt to match a result from the target\r\n    // with each parser in their supplied order.\r\n    // The parsers themselves are responsible for error propogation.\r\n    for (const p of parsers) {\r\n        nextState = p.parse(nextState);\r\n\r\n        if (nextState.isError) { return nextState; }\r\n        results.push(nextState.result);\r\n    }\r\n\r\n    return updateParserState(nextState, results);\r\n})\r\n\r\n/**\r\n * Defines a new parser that parses a target with a choice of parses, returning\r\n * the first successful result of the supplied parser choices.\r\n * The parser choices are applied in the order they are supplied.\r\n * @param parsers Parser[], an array of parsers to serve as choices to parse a target.\r\n * @returns Parser, the choice parser.\r\n */\r\nconst choice = <T = any>(parsers: Parser<T>[]) => new Parser((parserState: ParserState<T>) => {\r\n    if (parserState.isError) { return parserState; }\r\n\r\n    // Attempt to match a result in the target string\r\n    // with the supplied parser in their given order,\r\n    // return the first success.\r\n    for (const p of parsers) {\r\n        const nextState = p.parse(parserState);\r\n        if(!nextState.isError) { return nextState; }\r\n    }\r\n\r\n    // Couldn't match with any supplied parser.\r\n    return updateParserError(parserState, `choice: Unabled to match with any choice parser at index ${parserState.index}.`);\r\n})\r\n\r\n/**\r\n * Defines a new parser that attempts to parse a target with\r\n * the supplied parser as many times as possible.\r\n * @param parser Parser, the parser to parse against.\r\n * @param assertResult boolean<Optional>, if true, throw an error if no results are matched.\r\n * @returns Parser, the many parser.\r\n */\r\nconst many = <T>(parser: Parser<T>, assertResult?: boolean) => new Parser((parserState: ParserState<T[]>) => {\r\n    if (parserState.isError) { return parserState; }\r\n\r\n    const results = [] as T[];\r\n    let nextState: ParserState<T | T[]> = parserState;\r\n\r\n    // Attempt to match result in the given string\r\n    // with the supplied parser until an error is encountered.\r\n    while (true) {\r\n        const testState = parser.parse(nextState);\r\n        \r\n        if (!testState.isError) {\r\n            results.push(testState.result);\r\n            nextState = testState;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // If a result is asserted and none are matched, return an error.\r\n    if (assertResult && results.length === 0) {\r\n        return updateParserError(nextState, `many1: Unable to match any input using parser at index ${nextState.index}.`)\r\n    }\r\n\r\n    return updateParserState(nextState, results);\r\n});\r\n\r\n/**\r\n * Defines a new parser from a seperator parser and a value parser. The value parser will be used to \r\n * match values that are seperated by string sequences which are themselves matched by the seperator parser.\r\n * @param seperatorParser Parser, the parser to match the seperation delimeters.\r\n * @param assertResult boolean<Optional>, if true, throw an error if no results are matched.\r\n * @returns Parser, the sepBy parser.\r\n */\r\nconst sepBy = <S, T>(seperatorParser: Parser<S>, assertResult?: boolean) => (valueParser: Parser<T>) => new Parser((parserState: ParserState<T>) => {\r\n    const results = [] as T[];\r\n    let nextState: ParserState<S | T | T[]> = parserState;\r\n\r\n    while (true) {\r\n        const matchState = valueParser.parse(nextState);\r\n        if (matchState.isError) { break; }\r\n\r\n        results.push(matchState.result);\r\n        nextState = matchState;\r\n\r\n        const seperatorState = seperatorParser.parse(nextState);\r\n        if (seperatorState.isError) { break; }\r\n        nextState = seperatorState;\r\n    }\r\n\r\n    // If a result is asserted and none are matched, return an error.\r\n    if (assertResult && results.length === 0) {\r\n        return updateParserError(nextState, `sepBy1: Unable to match any input using parser at index ${nextState.index}.`)\r\n    }\r\n\r\n    return updateParserState(nextState, results);\r\n})\r\n\r\n/**\r\n * Defines a new parser that attempts to parse a target with\r\n * the supplied parser as many times as possible. Atleast one result\r\n * must be matched, otherwise an error is thrown.\r\n * @param parser Parser, the parser to parse against.\r\n * @returns Parser, the many parser.\r\n */\r\nconst many1 = <T>(parser: Parser<T>) => many(parser, true);\r\n/**\r\n * Defines a new parser from a seperator parser and a value parser. The value parser will be used to \r\n * match values that are seperated by string sequences which are themselves matched by the seperator parser.\r\n * Atleast one result must be matched, otherwise an error is thrown.\r\n * @param seperatorParser Parser, the parser to match the seperation delimeters.\r\n * @returns Parser, the sepBy parser.\r\n */\r\nconst sepBy1 = <S, T>(seperatorParser: Parser<S>, valueParser: Parser<T>) => sepBy<S,T>(seperatorParser, true)(valueParser);\r\n\r\n/**\r\n * Defines a parser that consists of a left, right and content parser. The\r\n * content parser will be applied to the target between matches for the left parser\r\n * and then the right parser.\r\n * @param leftParser Parser, defines what must be matched left of content.\r\n * @param rightParser Parser, defines what must be matched right of content.\r\n * @returns Parser, the between parser.\r\n */\r\nconst between = <L, T, R>(leftParser: Parser<L>, rightParser: Parser<R>) => (contentParser: Parser<T>) => sequenceOf([\r\n    leftParser,\r\n    contentParser,\r\n    rightParser\r\n]).map(results => results[1]);\r\n\r\n/*** Lazy support ***/\r\n/**\r\n * Defines a new parser from a parser thunk to support lazy\r\n * parser evaluation for recursive parser support.\r\n * @param parserThunk ParserThunk, a void function that returns a lazily returns a parser.\r\n * @returns Parser, the lazily loaded parser.\r\n */\r\nconst lazy = <T>(parserThunk: ParserThunk<T>) => new Parser(parserState => {\r\n    const parser = parserThunk();\r\n    return parser.parse(parserState);\r\n})\r\n\r\n/*** Condition Assertions ***/\r\n/**\r\n * Defines a new parser that will update the current state with the \r\n * supplied error message to assert a fail case.\r\n * @param errorMessage string, the error message.\r\n * @returns Parser, the fail parser.\r\n */\r\nconst fail = <T>(errorMessage: string): Parser<T> => new Parser(parserState => {\r\n    return updateParserError(parserState, errorMessage);\r\n})\r\n  \r\n/**\r\n * Defines a new parser that will update the current state with the \r\n * supplied value to assert a success case\r\n * @param value any, the value to update the state with.\r\n * @returns Parser, the success parser.\r\n */\r\nconst success = <T>(value: any): Parser<T> => new Parser(parserState => {\r\n    return updateParserState(parserState, value);\r\n})\r\n\r\n/**\r\n * Contextual parser that exploits couroutines to feed the current parse\r\n * result into the parser to use in the next parsing step.\r\n * @param generatorFn Generator, the parsing coroutine.\r\n * @returns Parser, the contextual parser.\r\n */\r\nconst contextual = <T>(generatorFn: () => Generator<Parser<T>, any, any>): Parser<T> => new Parser(parserState => {\r\n    const generator = generatorFn();\r\n\r\n    let nextValue = undefined;\r\n    let nextState = parserState;\r\n\r\n    // Executes a parse step until completion\r\n    while (true) {\r\n        const result = generator.next(nextValue);\r\n        const value = result.value;\r\n        const done = result.done;\r\n\r\n        // If done state, return final result\r\n        if (done) {\r\n            return updateParserState(nextState, value);\r\n        }\r\n\r\n        // Not done and no value, error\r\n        if (!(value && value instanceof Parser)) {\r\n        throw new Error(\r\n            `[coroutine] yielded values must be Parsers, got ${result.value}.`,\r\n        );\r\n        }\r\n\r\n        // Otherwise, parse the next state and store the value if no errors\r\n        nextState = value.parse(nextState);\r\n        if (nextState.isError) {\r\n            return nextState;\r\n        }\r\n\r\n        nextValue = nextState.result;\r\n    }\r\n});\r\n\r\n/**\r\n * Attempts to match the specified parser but doesn't\r\n * fail if no match is found.\r\n * @param parser Parser, the parser to parse against.\r\n * @returns Parser, the possibly parser.\r\n */\r\nconst possibly = <T>(parser: Parser<T>): Parser<T> => new Parser(parserState => {\r\n    if (parserState.isError) { return parserState; }\r\n\r\n    const nextState = parser.parse(parserState);\r\n    return nextState.isError ? (updateParserState(parserState, null)) : nextState;\r\n})\r\n\r\n/**\r\n * Matches the specified parser to the current state without consuming \r\n * the input.\r\n * @param parser Parser, the parser to parse against.\r\n * @returns Parser, the lookAhead parser.\r\n */\r\nconst lookAhead = <T>(parser: Parser<T>): Parser<T> => new Parser(parserState => {\r\n    if (parserState.isError) { return parserState; }\r\n\r\n    const nextState = parser.parse(parserState);\r\n    return nextState.isError ?\r\n        updateParserError(parserState, nextState.error)\r\n        :\r\n        updateParserState(parserState, nextState.result)\r\n})\r\n\r\n/*** Lexers ***/\r\nconst RE_LETTERS = /^[A-Za-z]*/;     // Regex to match letters.\r\nconst RE_LETTER = /[a-zA-Z]/;        // Regex to match single letter.\r\nconst RE_DIGITS = /^[0-9]*/;         // Regex to match digits.\r\nconst RE_DIGIT = /[0-9]*/;           // Regex to match digits.\r\nconst RE_WHITESPACES = /^\\s+/;       // Regex to match whitepsace.\r\nconst RE_ALL = /.+?(?=\\n)/;          // Regex to match anything.\r\nconst RE_NEW_LINE = /\\r?\\n/;\r\n\r\n/**\r\n * A letter or digit lexer wrapper, with type being specified.\r\n * @param parseType LetterDigits, the type to tokenize: letters or digits.\r\n * @returns ParserState, the state following parsing completion.\r\n */\r\nconst regex = (re: RegExp) => new Parser((parserState: ParserState<string>) => {\r\n    const {\r\n        targetString, \r\n        index,\r\n        isError\r\n    } = parserState;\r\n\r\n    if (isError) return parserState;\r\n\r\n    const slicedTarget = targetString.slice(index);\r\n    if (slicedTarget.length === 0) {\r\n        return updateParserError(parserState, `regex: Got unexpected end of input.`)\r\n    }\r\n    \r\n    // Match using type regex\r\n    const regexMatch = slicedTarget.match(re);\r\n\r\n    // Matched string will be empty if nothing was matched.\r\n    if (regexMatch && regexMatch[0].length !== 0) {\r\n        return updateParserState(parserState, regexMatch[0], index + regexMatch[0].length);\r\n    }\r\n\r\n    return updateParserError(parserState, `regex: Couldnt match digits at index ${index}.`)\r\n})\r\n\r\n//***  Generic Lexers ***/\r\nconst letters = regex(RE_LETTERS);\r\nconst letter = regex(RE_LETTER);\r\nconst digits = regex(RE_DIGITS);\r\nconst digit = regex(RE_DIGIT);\r\nconst whitespace = regex(RE_WHITESPACES);\r\nconst comment = char(';')                       // Anything following ; until next line\r\n    .chain(() => mapJoin(sequenceOf([\r\n        optionalWhitespace,\r\n        regex(RE_ALL),\r\n        possibly(regex(RE_NEW_LINE)),\r\n        optionalWhitespace\r\n    ])));\r\nconst optionalWhitespace = possibly(whitespace).map(result => result || '');\r\nconst optionalComment = possibly(comment).map(result => result || 'comment');\r\n\r\nexport type { Parser };\r\nexport default {\r\n    Parser,\r\n    str,\r\n    char,\r\n    sequenceOf,\r\n    choice,\r\n    between,\r\n    many,\r\n    many1,\r\n    sepBy,\r\n    sepBy1,\r\n    contextual,\r\n    possibly,\r\n    lookAhead,\r\n\r\n    regex,\r\n    letters,\r\n    letter,\r\n    digits,\r\n    digit,\r\n    whitespace,\r\n    comment,\r\n    optionalWhitespace,\r\n    optionalComment,\r\n\r\n    lazy,\r\n    fail,\r\n    success,\r\n\r\n    updateParserState,\r\n    updateParserError\r\n};\r\n","import { asType, ParserTypes } from \"./util\";\r\n\r\n// ParserTypes: wrap and tokenize a node with the appropriate type label for parsing.\r\nexport const parserTypes = {\r\n    register:                   asType(ParserTypes.REGISTER),\r\n    hexLiteral:                 asType(ParserTypes.HEX_LITERAL),\r\n    variable:                   asType(ParserTypes.VARIABLE),\r\n    address:                    asType(ParserTypes.ADDRESS),\r\n\r\n    opPlus:                     asType(ParserTypes.OP_PLUS),\r\n    opMinus:                    asType(ParserTypes.OP_MINUS),\r\n    opMultiply:                 asType(ParserTypes.OP_MULTIPLY),\r\n\r\n    binaryOperation:            asType(ParserTypes.BINARY_OPERATION),\r\n    bracketedExpression:        asType(ParserTypes.BRACKETED_EXPRESSION),\r\n    squareBracketedExpression:  asType(ParserTypes.SQUARE_BRACKETED_EXPRESSION),\r\n\r\n    label:                      asType(ParserTypes.LABEL),                            \r\n    instruction:                asType(ParserTypes.INSTRUCTION),\r\n\r\n    data:                       asType(ParserTypes.DATA),\r\n    constant:                   asType(ParserTypes.CONSTANT),\r\n    structure:                  asType(ParserTypes.STRUCTURE),\r\n    interpretAs:                asType(ParserTypes.INTERPRET_AS)\r\n};\r\n","import registers from \"../../cpu/registers\";\r\nimport Arc, { Parser } from \"../parser/arc/index\";\r\nimport { IReturn } from \"./instructions/generic\";\r\nimport { parserTypes } from \"./parserTypes\";\r\nimport { mapJoin, ParserTypes } from \"./util\";\r\n\r\n/*** Various common parsers ***/\r\n\r\n/**\r\n * Matches the specified string in fully upper or\r\n * lower case (used for mnemonics).\r\n * @param s string, the string to match.\r\n * @returns Parser, the parser.\r\n */\r\nconst upperOrLowerStr = (s: string): Parser<string, string> => Arc.choice([\r\n    Arc.str(s.toUpperCase()),\r\n    Arc.str(s.toLowerCase())\r\n]);\r\n\r\n/**\r\n * Matches the next character without consuming the input.\r\n */\r\nconst peek: Parser<string, string> = Arc.lookAhead<string>(Arc.regex(/^./));\r\n\r\n/**\r\n * Matches a register label.\r\n */\r\nconst register: Parser<{ type: ParserTypes; value: any;}, string> = \r\n    Arc.choice(registers.map(registerLabel => upperOrLowerStr(registerLabel)))\r\n       .map(parserTypes.register);\r\n\r\n/**\r\n * Matches a hexadecimal digit.\r\n */\r\nconst hexDigit: Parser<string, string> = Arc.regex(/^[0-9A-Fa-f]/);\r\n\r\n/**\r\n * Matches a hexadecimal literal : $ABCD.\r\n */\r\nconst hexLiteral: Parser<{ type: ParserTypes; value: any;}, string> = \r\n    Arc.char('$')\r\n       .chain(() => mapJoin(Arc.many1(hexDigit)))\r\n       .map(parserTypes.hexLiteral);\r\n\r\n/**\r\n * Matches a memory address : &ABCD.\r\n */\r\nconst address: Parser<{ type: ParserTypes; value: any;}, string> = \r\n    Arc.char('&')\r\n       .chain(() => mapJoin(Arc.many1(hexDigit)))\r\n       .map(parserTypes.address);\r\n\r\n/**\r\n * Matches a valid label.\r\n */\r\nconst validLabelIdentifier = mapJoin(Arc.sequenceOf([\r\n    Arc.regex(/^[a-zA-Z_]/),\r\n    Arc.possibly(Arc.regex(/^[a-zA-Z0-9_]+/))\r\n       .map(x => x === null ? '' : x)\r\n]));\r\n\r\n/**\r\n * Matches a variable label : !loc\r\n */\r\nconst variable = Arc.str('!')\r\n    .chain(() => validLabelIdentifier)\r\n    .map(parserTypes.variable);\r\n\r\n/**\r\n * Matches a valid arithmetic operator for binary expressions : +, - and *.\r\n */\r\nconst operator = Arc.choice([\r\n    Arc.char('+').map(parserTypes.opPlus),\r\n    Arc.char('-').map(parserTypes.opMinus),\r\n    Arc.char('*').map(parserTypes.opMultiply)\r\n]);\r\n\r\n/**\r\n * Matches a code section label - start:\r\n */\r\nconst label: Parser<IReturn> = Arc.sequenceOf([\r\n    validLabelIdentifier,\r\n    Arc.char(':'),\r\n    Arc.optionalWhitespace\r\n])\r\n.map(([labelName]) => labelName)\r\n.map(parserTypes.label);\r\n\r\nconst optionalWhitespaceSurrounded = Arc.between(Arc.optionalWhitespace, Arc.optionalWhitespace);   // Match item optionally surrounded by whitespace\r\nconst commaSeperated = Arc.sepBy(optionalWhitespaceSurrounded(Arc.char(',')));                      // Match comma seperated items\r\n\r\nexport interface Expression {\r\n    type: ParserTypes,\r\n    value: any\r\n};\r\n\r\n/**\r\n * Disambiguates the order of operations for the given binary\r\n * expressions such that bedmas is preservered.\r\n * @param expr The epxression to disambiguate.\r\n * @returns The disambiguated expression\r\n */\r\nconst disambiguateOrderOfOperations = (expr: Expression) => {\r\n    if (expr.type !== ParserTypes.SQUARE_BRACKETED_EXPRESSION \r\n        && expr.type !== ParserTypes.BRACKETED_EXPRESSION) {\r\n        return expr;\r\n    }\r\n\r\n    // value is array\r\n    if (expr.value.length === 1) {\r\n        return expr.value[0];\r\n    }\r\n\r\n    const operationPriorities = {\r\n        OP_MULTIPLY: 2,\r\n        OP_PLUS: 1,\r\n        OP_MINUS: 0\r\n    };\r\n\r\n    let candidateExpression = {\r\n        priority: -Infinity,\r\n        leftOpr: null,\r\n        rightOpr: null,\r\n        op: null\r\n    }\r\n\r\n    // Loop over operators\r\n    for (let i = 1; i < expr.value.length; i+=2) {\r\n        const level = operationPriorities[expr.value[i].type];\r\n        if (level > candidateExpression.priority) {\r\n            candidateExpression = {\r\n                priority: level,\r\n                leftOpr: i - 1,\r\n                rightOpr: i + 1,\r\n                op: expr.value[i]\r\n            }\r\n        }\r\n    }\r\n\r\n    // Recursively disambiguate each operation by comparing it with the one to its left and the one to its right\r\n    // until we've run out of bracketed expressions.\r\n    const newExpression = parserTypes.bracketedExpression([\r\n        ...expr.value.slice(0, candidateExpression.leftOpr),\r\n        parserTypes.binaryOperation({\r\n            a: disambiguateOrderOfOperations(expr.value[candidateExpression.leftOpr]),\r\n            b: disambiguateOrderOfOperations(expr.value[candidateExpression.rightOpr]),\r\n            op: candidateExpression.op\r\n        }),\r\n        ...expr.value.slice(candidateExpression.rightOpr + 1)\r\n    ]);\r\n\r\n    return disambiguateOrderOfOperations(newExpression);\r\n}\r\n\r\nexport {\r\n    upperOrLowerStr,\r\n    peek,\r\n    register,\r\n    hexDigit,\r\n    hexLiteral,\r\n    address,\r\n    validLabelIdentifier,\r\n    variable,\r\n    operator,\r\n    label,\r\n    disambiguateOrderOfOperations,\r\n    commaSeperated\r\n};\r\n","import Arc from \"../parser/arc/index\";\r\nimport { validLabelIdentifier } from \"./common\";\r\nimport { parserTypes } from \"./parserTypes\";\r\n\r\n/**\r\n * Matches a data cast <Rectangle> myRectangle.y\r\n */\r\nconst interpretAs = Arc.contextual(function* () {\r\n    yield Arc.char('<');                                    // Match the caster: <Rectangle>\r\n    const structureName = yield validLabelIdentifier;\r\n    yield Arc.char('>');\r\n\r\n    yield Arc.optionalWhitespace;                           // Match the castee datum and its member: myRectangle.y\r\n    const symbol = yield validLabelIdentifier;\r\n    yield Arc.char('.');\r\n    const property = yield validLabelIdentifier;\r\n    yield Arc.optionalWhitespace\r\n\r\n    return parserTypes.interpretAs({                        // Return the wrapped node.\r\n        structureName,\r\n        symbol,\r\n        property\r\n    });\r\n});\r\n\r\nexport {\r\n    interpretAs\r\n}\r\n","import Arc from \"../parser/arc/index\";\r\nimport { disambiguateOrderOfOperations, hexLiteral, operator, peek, variable } from \"./common\";\r\nimport { parserTypes } from \"./parserTypes\";\r\nimport { last, typifyBracketedExpression } from \"./util\";\r\nimport { interpretAs } from \"./interpretAs\";\r\n\r\n// Expression elements: literal $AB, variable [!loc] or interpreted datum <Rectangle> myRect.y\r\nconst expressionElement = Arc.choice([\r\n    hexLiteral,\r\n    variable,\r\n    interpretAs\r\n])\r\n\r\n//TODO: solve the type error\r\n/**\r\n * Matches a nested bracketed expression i.e (1 + (2 * 4))\r\n * via state machine.\r\n */\r\n// @ts-ignore\r\nconst bracketedExpr = Arc.contextual(function* () {\r\n    enum states {\r\n        OPEN_BRACKET=0,                                             // Match open bracket next\r\n        OPERATOR_OR_CLOSING_BRACKET=1,                              // Match operator or close bracket next\r\n        ELEMENT_OR_OPENING_BRACKET=2,                               // Match expr element or open bracket next\r\n        CLOSE_BRACKET=3                                             // Match close bracket next\r\n    };\r\n    const expr = [] as (string | number | (string | number)[])[];   // Holds our expressions\r\n    const stack = [expr];                                           // Holds the last expression so we can \r\n                                                                    // always modify the latest one\r\n    yield Arc.char('(');\r\n\r\n    let state = states.ELEMENT_OR_OPENING_BRACKET;                  \r\n\r\n    let flag = true;\r\n    while (flag) {\r\n        const nextChar: string = yield peek;\r\n\r\n        switch(state) {\r\n            case states.OPEN_BRACKET: {                         // Match an open bracket\r\n                yield Arc.char('(');\r\n                expr.push([]);                                  // Indicates a new expression, push it\r\n                stack.push(last(expr));\r\n                yield Arc.optionalWhitespace;\r\n                state = states.ELEMENT_OR_OPENING_BRACKET;\r\n                continue;\r\n            }\r\n\r\n            case states.OPERATOR_OR_CLOSING_BRACKET: {          // Either match the next op or close expression.\r\n                if (nextChar === ')') {                         // If next is close bracket, head to close bracket state\r\n                    state = states.CLOSE_BRACKET;\r\n                    continue;\r\n                }\r\n\r\n                last(stack).push(yield operator);               // Otherwise push the current operator into our current expression\r\n                yield Arc.optionalWhitespace;\r\n                state = states.ELEMENT_OR_OPENING_BRACKET;\r\n                continue;\r\n            }\r\n            \r\n            case states.ELEMENT_OR_OPENING_BRACKET: {           // Match the next element or open bracket\r\n                if (nextChar === ')') {                         // We're not expecting a ) after an open bracket/ operator, error.\r\n                    yield Arc.fail<string>(\"Unexpected end of expression\");\r\n                    break;\r\n                }\r\n\r\n                if (nextChar === \"(\") {                         // If new bracket, head to open bracket state\r\n                    state = states.OPEN_BRACKET;\r\n                } else {\r\n                    // MOV LIT REG so no register\r\n                    last(stack).push(yield expressionElement);  // Otherwise, new value push to current expression\r\n                    yield Arc.optionalWhitespace;\r\n                    state = states.OPERATOR_OR_CLOSING_BRACKET;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            case states.CLOSE_BRACKET: {                        // Match a close bracket\r\n                yield Arc.char(')');\r\n                stack.pop();                                    // Indicates end of expression, pop it\r\n                if (stack.length === 0) {                       // Done if no more expressions\r\n                    flag = false;\r\n                    break;\r\n                }\r\n\r\n                yield Arc.optionalWhitespace;\r\n                state = states.OPERATOR_OR_CLOSING_BRACKET;\r\n                continue;\r\n            }\r\n\r\n            default:\r\n                throw new Error(\"Reached undefined state in parse finite state machine: 'Bracketed Expression'\");\r\n        }\r\n    }\r\n\r\n    // Typify each expression\r\n    return typifyBracketedExpression(expr);\r\n});\r\n\r\n\r\n/**\r\n * Matches a nested square bracketed expression i.e [1 + [2 * 4]]\r\n * via state machine.\r\n */\r\nconst squareBracketExpr = Arc.contextual(function* () {\r\n    enum states {\r\n        EXPECT_ELEMENT=0,\r\n        EXPECT_OPERATOR=1\r\n    };\r\n    let state = states.EXPECT_ELEMENT;\r\n\r\n    yield Arc.char('[');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const expr = [] as (string | number)[];     // Stores the expression elements\r\n\r\n    let flag = true;\r\n    while (flag) {\r\n        switch(state) { \r\n            case states.EXPECT_ELEMENT: {               // Matches an element -> either a bracket expression\r\n                                                        // or an expression element.\r\n                const result = yield Arc.choice([\r\n                    bracketedExpr,\r\n                    expressionElement\r\n                ]);\r\n                expr.push(result);  \r\n                state = states.EXPECT_OPERATOR;         // Now we need an operator\r\n                yield Arc.optionalWhitespace;\r\n                continue;\r\n            }\r\n\r\n            case states.EXPECT_OPERATOR: {              // Matches operator or end of expression\r\n                const nextChar: string = yield peek;\r\n                if (nextChar === ']') {                 // Matched end\r\n                    yield Arc.char(']');\r\n                    yield Arc.optionalWhitespace;\r\n                    flag = false;\r\n                    break;\r\n                }\r\n                \r\n                const result = yield operator;          // Matched operator, add it then expect another element\r\n                expr.push(result);\r\n                state = states.EXPECT_ELEMENT;\r\n                yield Arc.optionalWhitespace;\r\n                continue;\r\n            }\r\n\r\n            default:\r\n                throw new Error(\"Reached undefined state in parse finite state machine: 'Square Bracket Expression'\");\r\n        }\r\n    }\r\n\r\n    return parserTypes.squareBracketedExpression(expr);\r\n}).map(disambiguateOrderOfOperations);  // Disambiguate the order of operations within the expression\r\n\r\nexport {\r\n    squareBracketExpr,\r\n    bracketedExpr\r\n}\r\n","import Arc from \"../arc/index\";\r\nimport { InstructionMnemonic, instructionType } from \"../../../cpu/instructions\";\r\nimport {\r\n    regReg,\r\n    litReg,\r\n    regMem,\r\n    memReg,\r\n    litMem,\r\n    regIndReg,\r\n    litOffReg,\r\n    noArgs,\r\n    singleReg,\r\n    singleLit,\r\n    regLit\r\n} from \"./generic\";\r\n\r\nconst { \r\n    MOV, \r\n    ADD,\r\n    SUB, \r\n    MUL,\r\n    AND,\r\n    OR,\r\n    XOR,\r\n    LSL,\r\n    LSR,\r\n    INC,\r\n    DEC,\r\n    NOT,\r\n    JEQ,\r\n    JNE,\r\n    JLT,\r\n    JGT,\r\n    JLE,\r\n    JGE,\r\n    PSH,\r\n    POP,\r\n    CAL,\r\n    RET,\r\n    HLT  \r\n} = InstructionMnemonic;\r\n\r\n/*** ========================================\r\n * Create the parsers for each instruction wrapped by the corresponding generic \r\n * =========================================== ***/\r\nconst mov = Arc.choice([\r\n    regReg(MOV, instructionType[MOV].regReg),\r\n    litReg(MOV, instructionType[MOV].litReg),\r\n    memReg(MOV, instructionType[MOV].memReg),\r\n    regMem(MOV, instructionType[MOV].regMem),\r\n    litMem(MOV, instructionType[MOV].litMem),\r\n    regIndReg(MOV, instructionType[MOV].regIndReg),\r\n    litOffReg(MOV, instructionType[MOV].litOffReg)\r\n]);\r\n\r\nconst add = Arc.choice([\r\n    regReg(ADD, instructionType[ADD].regReg),\r\n    litReg(ADD, instructionType[ADD].litReg)\r\n]);\r\n\r\nconst sub = Arc.choice([\r\n    regReg(SUB, instructionType[SUB].regReg),\r\n    regLit(SUB, instructionType[SUB].regLit),\r\n    litReg(SUB, instructionType[SUB].litReg),\r\n]);\r\n\r\nconst mul = Arc.choice([\r\n    regReg(MUL, instructionType[MUL].regReg),\r\n    litReg(MUL, instructionType[MUL].litReg)\r\n]);\r\n\r\nconst and = Arc.choice([\r\n    regReg(AND, instructionType[AND].regReg),\r\n    regLit(AND, instructionType[AND].regLit)\r\n]);\r\n\r\nconst or = Arc.choice([\r\n    regReg(OR, instructionType[OR].regReg),\r\n    regLit(OR, instructionType[OR].regLit)\r\n]);\r\n\r\nconst xor = Arc.choice([\r\n    regReg(XOR, instructionType[XOR].regReg),\r\n    regLit(XOR, instructionType[XOR].regLit)\r\n]);\r\n\r\nconst lsl = Arc.choice([\r\n    regReg(LSL, instructionType[LSL].regReg),\r\n    regLit(LSL, instructionType[LSL].regLit)\r\n]);\r\n\r\nconst lsr = Arc.choice([\r\n    regReg(LSR, instructionType[LSR].regReg),\r\n    regLit(LSR, instructionType[LSR].regLit)\r\n]);\r\n\r\nconst inc = singleReg(INC, instructionType[INC].singleReg);\r\nconst dec = singleReg(DEC, instructionType[DEC].singleReg);\r\nconst not = singleReg(NOT, instructionType[NOT].singleReg);\r\n\r\nconst jeq = Arc.choice([\r\n    regMem(JEQ, instructionType[JEQ].regMem),\r\n    litMem(JEQ, instructionType[JEQ].litMem)\r\n]);\r\n\r\nconst jne = Arc.choice([\r\n    regMem(JNE, instructionType[JNE].regMem),\r\n    litMem(JNE, instructionType[JNE].litMem)\r\n]);\r\n\r\nconst jlt = Arc.choice([\r\n    regMem(JLT, instructionType[JLT].regMem),\r\n    litMem(JLT, instructionType[JLT].litMem)\r\n]);\r\n\r\nconst jgt = Arc.choice([\r\n    regMem(JGT, instructionType[JGT].regMem),\r\n    litMem(JGT, instructionType[JGT].litMem)\r\n]);\r\n\r\nconst jle = Arc.choice([\r\n    regMem(JLE, instructionType[JLE].regMem),\r\n    litMem(JLE, instructionType[JLE].litMem)\r\n]);\r\n\r\nconst jge = Arc.choice([\r\n    regMem(JGE, instructionType[JGE].regMem),\r\n    litMem(JGE, instructionType[JGE].litMem)\r\n]);\r\n\r\nconst psh = Arc.choice([\r\n    singleLit(PSH, instructionType[PSH].singleLit),\r\n    singleReg(PSH, instructionType[PSH].singleReg)\r\n]);\r\n\r\nconst pop = singleReg(POP, instructionType[POP].singleReg);\r\n\r\nconst cal = Arc.choice([\r\n    singleLit(CAL, instructionType[CAL].singleLit),\r\n    singleReg(CAL, instructionType[CAL].singleReg)\r\n]);\r\n\r\nconst ret = noArgs(RET, instructionType[RET].noArgs);\r\nconst hlt = noArgs(HLT, instructionType[HLT].noArgs);\r\n\r\nexport const instruction = Arc.choice([\r\n    mov,\r\n\r\n    add,\r\n    sub,\r\n    mul,\r\n    or,\r\n    and,\r\n    xor,\r\n    not,\r\n    lsl,\r\n    lsr,\r\n\r\n    inc,\r\n    dec,\r\n    \r\n    jne,\r\n    jeq,\r\n    jlt,\r\n    jgt,\r\n    jle,\r\n    jge,\r\n    \r\n    psh,\r\n    pop,\r\n    cal,\r\n    ret,\r\n    hlt\r\n]);","import Arc, { Parser } from \"../parser/arc/index\";\r\nimport { validLabelIdentifier, hexLiteral, commaSeperated } from \"./common\";\r\nimport { IReturn } from \"./instructions/generic\";\r\nimport { parserTypes } from \"./parserTypes\";\r\n\r\n/**\r\n * Generic data parser: +data16 rectangle = { $A6, $B4, $C9, $DA }\r\n * Basically an array\r\n * @param size the element size: bytes (8B) or half words (16B)\r\n * @returns Parser, the data parser.\r\n */\r\nconst dataParser = (size: number): Parser<IReturn> => Arc.contextual(function* () {\r\n    const isExport = Boolean(yield Arc.possibly(Arc.char('+')));        // + indicates an exported member\r\n    yield Arc.str(`data${size}`);                                       // Match data identifier\r\n\r\n    yield Arc.whitespace;                                               // Match = open bracket\r\n    const name = yield validLabelIdentifier;\r\n    yield Arc.whitespace;\r\n    yield Arc.char('=');\r\n    yield Arc.whitespace;\r\n    yield Arc.char('{');\r\n    yield Arc.whitespace;\r\n\r\n    const values = yield commaSeperated(hexLiteral);                    // Match the data elements and close bracket\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char('}');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    return parserTypes.data({                                           // Return the wrapped node\r\n        size,\r\n        isExport,\r\n        name,\r\n        values\r\n    });\r\n})\r\n\r\n// Data Parser for byte and halfword elements\r\nconst data8 = dataParser(8);\r\nconst data16 = dataParser(16);\r\n\r\nexport {\r\n    data8,\r\n    data16\r\n}\r\n","import Arc, { Parser } from \"../parser/arc/index\";\r\nimport { validLabelIdentifier, hexLiteral } from \"./common\";\r\nimport { IReturn } from \"./instructions/generic\";\r\nimport { parserTypes } from \"./parserTypes\";\r\n\r\n/**\r\n * Matches a constant directive: constant index = $C0DE\r\n */\r\nconst constantParser: Parser<IReturn> = Arc.contextual(function* () {\r\n    const isExport = Boolean(yield Arc.possibly(Arc.char('+')));    // + indicates an exported member\r\n    yield Arc.str(\"constant\");                                      // Match \"constant\" followed by label\r\n    yield Arc.whitespace;\r\n    const name = yield validLabelIdentifier;\r\n    yield Arc.whitespace;\r\n\r\n    yield Arc.char('=');                                            // Match value\r\n    yield Arc.whitespace;\r\n    const value = yield hexLiteral;\r\n    yield Arc.optionalWhitespace;\r\n\r\n    return parserTypes.constant({                                   // Return wrapped node\r\n        isExport,\r\n        name, \r\n        value\r\n    });\r\n});\r\n\r\nexport {\r\n    constantParser\r\n};\r\n","import Arc, { Parser } from \"../parser/arc/index\";\r\nimport { validLabelIdentifier, hexLiteral, commaSeperated } from \"./common\";\r\nimport { IReturn } from \"./instructions/generic\";\r\nimport { parserTypes } from \"./parserTypes\";\r\n\r\n/**\r\n * Matches a key and value pair x : $45\r\n */\r\nconst keyValuePair = Arc.contextual(function* () {\r\n    yield Arc.optionalWhitespace;                   // Match key\r\n    const key = yield validLabelIdentifier;\r\n\r\n    yield Arc.optionalWhitespace;                   // Match colon\r\n    yield Arc.char(':');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    const value = yield hexLiteral;                 // Match value\r\n    yield Arc.optionalWhitespace;\r\n\r\n    return { key, value };\r\n});\r\n\r\n/**\r\n * Matches a structure of the form: structure data {\r\n                                            x: $4,\r\n                                            y: $AA,\r\n                                            w: $2,\r\n                                            z: $A\r\n                                        }\r\n */\r\nconst structureParser: Parser<IReturn> = Arc.contextual(function* () {\r\n    const isExport = Boolean(yield Arc.possibly(Arc.char('+')));            // + indicates exported member\r\n\r\n    yield Arc.str(\"structure\");                                             // Match structure keyword and label {\r\n    yield Arc.whitespace;\r\n\r\n    const name = yield validLabelIdentifier;                                \r\n    yield Arc.whitespace;\r\n    yield Arc.char('{');\r\n    yield Arc.whitespace;\r\n\r\n    const members = yield commaSeperated(keyValuePair);                     // Match key value pairs }\r\n\r\n    yield Arc.optionalWhitespace;\r\n    yield Arc.char('}');\r\n    yield Arc.optionalWhitespace;\r\n\r\n    return parserTypes.structure({                                          // Return the wrapped node\r\n        isExport,\r\n        name,\r\n        members\r\n    });\r\n});\r\n\r\nexport {\r\n    structureParser\r\n}\r\n","import { instruction } from \"./instructions/instructions\";\r\nimport Arc from \"../parser/arc/index\";\r\nimport { label } from \"./common\";\r\nimport { data8, data16 } from \"./data\";\r\nimport { constantParser as constant } from \"./constant\";\r\nimport { structureParser as structure } from \"./structure\";\r\n\r\n// The harmonic assembly parser.\r\nexport const assemblyParser = Arc.many(\r\n    Arc.choice([\r\n        instruction, \r\n        label, \r\n        data8, \r\n        data16, \r\n        constant,\r\n        structure,\r\n        Arc.comment as any\r\n    ])\r\n);\r\n\r\n// For debug\r\n// const statement = `\r\n// ;hello\r\n// mov r1, r2 ; hey\r\n// add $C0DE, r2   ; ilu \r\n// mov r2, r1 ; ilu2\r\n// `.trim() + '\\n';\r\n// assemblyParser.run(statement);\r\n","/**\r\n * Test programs for debugging.\r\n */\r\n\r\nimport instructions from './instructions';\r\nimport registers from './registers';\r\n\r\n// General purpose register encodings (byte offset indices).\r\nexport const reg = registers.reduce((regMap: Record<string, number>, regName: string, idx: number) => {\r\n    regMap[regName.toUpperCase()] = idx;\r\n    return regMap;\r\n}, {} as Record<string, number>);\r\n\r\nlet i = 0;  // Counter to make writing easier for now.\r\n\r\n/**\r\n * Program that adds 0x1234 + 0abcd and stores \r\n * the result in Mmem[0x0100];\r\n * start:\r\n *      mov r1, #0x1234     ;\r\n *      mov r2, #0xabcd     ;\r\n *      add r1, r2          ;implicitly stores in acc\r\n *      str acc, #0x0100    ;\r\n * done:                    \r\n * @param writableBytes Uint8Array, the computer's main memory.\r\n */\r\nexport const storeMmem = (writableBytes: Uint8Array): void => {\r\n\r\n    // mov 0x1234 r1 : 0x10123401\r\n    // R1 <- 0-extend(0x1234)\r\n    // pc 0 -> 1 -> 3 -> 4\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = 0x12; //0x1234\r\n    writableBytes[i++] = 0x34;\r\n    writableBytes[i++] = reg.R1;\r\n\r\n    // mov 0xABCD r2 : 0x10ABCD02\r\n    // R2 <- 0-extend(0xABCD)\r\n    // pc 3 -> 4 -> 6 -> 7\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = 0xAB; //0xABCD\r\n    writableBytes[i++] = 0xCD;\r\n    writableBytes[i++] = reg.R2;\r\n\r\n    // *add r1 r2 [stored in accumulator: implicit] : 0x140102__.\r\n    // ACC <- [R1] + [R2]\r\n    // pc 6 -> 7 -> 8\r\n    writableBytes[i++] = instructions.ADD_RX_RY.opCode;\r\n    writableBytes[i++] = 0x1; // r1 idx\r\n    writableBytes[i++] = 0x2; //r2 idx\r\n\r\n    // str acc 0x0100 : 0x12080100 **NOT Reg or PC-relative\r\n    // Mmem[0-extend(0x0100)] <- [ACC]\r\n    writableBytes[i++] = instructions.STR_RS_MEM.opCode;\r\n    writableBytes[i++] = reg.ACC;\r\n    writableBytes[i++] = 0x01; // 0x0100\r\n    writableBytes[i++] = 0x00;\r\n}\r\n\r\n/**\r\n * Program that counts to three, storing the accumulated\r\n * result at Mmem[0x0100];\r\n * mov r2, 0x0001            ;increment (no imm16 yet)\r\n * start:\r\n *      ldr r1, #0x0100     ;Mmem[0x0100] initially 0\r\n *      add r1, r2          ;implicitly stores in acc\r\n *      str acc, #0x0100    ;\r\n *      jne #0x0003, start  ;\r\n * done:                    \r\n * @param writableBytes Uint8Array, the computer's main memory.\r\n */\r\nexport const countToThree = (writableBytes: Uint8Array): void => {\r\n    // mov r2, 0x0001;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R2;\r\n    writableBytes[i++] = 0x00; // 0x0001\r\n    writableBytes[i++] = 0x01;\r\n\r\n    // ldr r1, #0x0100;\r\n    writableBytes[i++] = instructions.LDR_MEM_RD.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n    writableBytes[i++] = 0x01; // 0x0100\r\n    writableBytes[i++] = 0x00;\r\n\r\n    // add r1, r2;\r\n    writableBytes[i++] = instructions.ADD_RX_RY.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n    writableBytes[i++] = reg.R2;\r\n    \r\n    // str acc, #0x0100\r\n    writableBytes[i++] = instructions.STR_RS_MEM.opCode;\r\n    writableBytes[i++] = reg.ACC;\r\n    writableBytes[i++] = 0x01; // 0x0001\r\n    writableBytes[i++] = 0x00;\r\n\r\n    // jne 0x0003, start; ~ CMP ACC, 0x0003;\r\n    //                      BNE start;\r\n    // assume label 'start' has address 0x0001 (it does for this unit alone).\r\n    writableBytes[i++] = instructions.JMP_NOT_EQ.opCode;\r\n    writableBytes[i++] = 0x00;  // 0x0003\r\n    writableBytes[i++] = 0x03; \r\n    writableBytes[i++] = 0x00;  // 0x0000: start address\r\n    writableBytes[i++] = 0x01;  \r\n}\r\n\r\n/**\r\n * Program that swaps the contents in R1 and R2 using\r\n * stack mechanics: push r1 r2 then pop r1 r2.\r\n * start:\r\n *      mov r1, #0x5151;\r\n *      mov r2, #0x4242;\r\n *      psh r1;\r\n *      psh r2;\r\n *      pop r1;\r\n *      pop r2;\r\n * done:\r\n * @param writableBytes Uint8Array, the computer's main memory.\r\n */\r\nexport const stackSwap = (writableBytes: Uint8Array): void => {\r\n    // mov r1, #0x5151;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n    writableBytes[i++] = 0x51; // 0x5151\r\n    writableBytes[i++] = 0x51;\r\n\r\n    // mov r2, #0x4242;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R2;\r\n    writableBytes[i++] = 0x42; // 0x4242\r\n    writableBytes[i++] = 0x42;\r\n\r\n    // psh r1;\r\n    writableBytes[i++] = instructions.PSH_RS.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n\r\n    // psh r2;\r\n    writableBytes[i++] = instructions.PSH_RS.opCode;\r\n    writableBytes[i++] = reg.R2;\r\n\r\n    // pop r2;\r\n    writableBytes[i++] = instructions.POP.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n\r\n    // psh r1;\r\n    writableBytes[i++] = instructions.POP.opCode;\r\n    writableBytes[i++] = reg.R2;\r\n}\r\n\r\n/**\r\n * Program to test subroutine branching and restoration\r\n * of stack frames.\r\n * @param writableBytes Uint8Array, the computer's main memory\r\n */\r\nexport const branchSubroutine = (writableBytes: Uint8Array): void => {\r\n    const subroutineAddress = 0x3000;\r\n    /* Push values on stack that should remain after return. */\r\n    // psh 0x3333;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x33; //0x3333\r\n    writableBytes[i++] = 0x33;\r\n\r\n    // psh 0x2222;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x22; //0x2222\r\n    writableBytes[i++] = 0x22;\r\n    \r\n    // psh 0x1111;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x11; //0x1111\r\n    writableBytes[i++] = 0x11;\r\n\r\n    /* Store values in registers to test restored. */\r\n    // mov r1, #0x1234;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n    writableBytes[i++] = 0x12; // 0x5151\r\n    writableBytes[i++] = 0x34;\r\n\r\n    // mov r1, #0x1234;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R4;\r\n    writableBytes[i++] = 0x56; // 0x5151\r\n    writableBytes[i++] = 0x78;\r\n\r\n    /* Calling subroutine@0x3000 with 0 args. */\r\n    // psh 0x0000;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x00; //0x0000\r\n    writableBytes[i++] = 0x00;\r\n\r\n    // cal subroutine\r\n    writableBytes[i++] = instructions.CAL_LIT.opCode;\r\n    writableBytes[i++] = (subroutineAddress & 0xff00) >> 8; //0x30\r\n    writableBytes[i++] = (subroutineAddress & 0x00ff);      //0x00\r\n\r\n    // psh 0x4444; Should also be preserved\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x44; //0x4444\r\n    writableBytes[i++] = 0x44;\r\n\r\n    // Subroutine; @0x3000\r\n    i = subroutineAddress\r\n\r\n    /* Test new stack frame */\r\n    // psh 0x0102;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x01; //0x0102\r\n    writableBytes[i++] = 0x02;\r\n\r\n    // psh 0x0304;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x03; //0x0304\r\n    writableBytes[i++] = 0x04;\r\n    \r\n    // psh 0x0506;\r\n    writableBytes[i++] = instructions.PSH_LIT.opCode;\r\n    writableBytes[i++] = 0x05; //0x0506\r\n    writableBytes[i++] = 0x06;\r\n\r\n    /* Register values should revert. */\r\n    // mov r1, #0x0708;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R1;\r\n    writableBytes[i++] = 0x07; // 0x4242\r\n    writableBytes[i++] = 0x08;\r\n\r\n    // mov r7, #0x090A;\r\n    writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n    writableBytes[i++] = reg.R7;\r\n    writableBytes[i++] = 0x09; // 0x090A\r\n    writableBytes[i++] = 0x0A;\r\n\r\n    writableBytes[i++] = instructions.RET.opCode;\r\n}\r\n\r\nexport const screenDeviceProgram = (writableBytes: Uint8Array): void => {\r\n    const writeCharToScreen = (char, command, position) => {\r\n        writableBytes[i++] = instructions.MOV_LIT_RD.opCode;\r\n        writableBytes[i++] = reg.R1;\r\n        writableBytes[i++] = command;\r\n        writableBytes[i++] = char.charCodeAt(0);\r\n\r\n        writableBytes[i++] = instructions.STR_RS_MEM.opCode;\r\n        writableBytes[i++] = reg.R1;\r\n        writableBytes[i++] = 0x30;\r\n        writableBytes[i++] = position;\r\n    }\r\n\r\n    writeCharToScreen(\" \", 0xff, 0); // Clear screen\r\n    \r\n    for (let idx = 0; idx <= 0xff; idx++) {\r\n        const command = idx % 2 === 0 ?\r\n            0x01\r\n            :\r\n            0x02;\r\n\r\n        writeCharToScreen(\"*\", command, idx);\r\n    }\r\n\r\n    writableBytes[i++] = instructions.HLT.opCode;\r\n}\r\n","import { assemblyParser as parser } from \"./parser/index\";\r\nimport instructionsMeta, { InstructionTypes as I } from \"../cpu/instructions\";\r\nimport { reg } from \"../cpu/programs\";\r\nimport { ParserTypes } from \"./parser/util\";\r\n\r\n// Big Endian : MSB is stored first\r\nlet machineCode = [] as number[];           // Stores the machine code \r\nlet parsedInstructions = [] as any[];       // Stores ast nodes\r\nlet labels = {};                            // Stores parsed label and their addresses\r\nlet structures = {};                        // Stores structures and their associated values\r\n\r\n//TODO: Add binary expression support\r\n/**\r\n * Returns the value associated with a specified label node.\r\n * @param node any, the node to extract the value from [literal or address].\r\n * @returns number, the value\r\n */\r\nconst getNodeValue = node => {\r\n    switch(node.type) { \r\n        case ParserTypes.VARIABLE: {                                        // Return the associated value in labels, if exist\r\n            if (!(node.value in labels)) {\r\n                throw new Error(`Label ${node.value} wasn't resolved.`)     // Else error\r\n            }\r\n            return labels[node.value];\r\n        }\r\n\r\n        case ParserTypes.INTERPRET_AS: {                                    // Translate the member to its data value using the\r\n            const structure = structures[node.value.structureName];         // the supplied offset. Else error.\r\n\r\n            if (!structure) {\r\n                throw new Error(`structure \"${node.value.structure}\" could not be resolved.`);\r\n            }\r\n\r\n            const member = structure.members[node.value.property];\r\n            if (!member) {\r\n                throw new Error(\r\n                    `propery \"${node.value.property}\" in structure \"${node.value.structure}\" could not be resolved.`\r\n                )\r\n            }\r\n\r\n            if (!(node.value.symbol in labels)) {\r\n                throw new Error(`symbol ${node.value.symbol} could not be resolved.`)\r\n            }\r\n            \r\n            const symbol = labels[node.value.symbol];                       // Data member associated value\r\n            return symbol + member.offset;                                  // Members offset off from base\r\n        }\r\n\r\n        case ParserTypes.HEX_LITERAL: {                                                                \r\n            return  parseInt(node.value, 16);\r\n        }\r\n        \r\n        case ParserTypes.ADDRESS: {\r\n            return  parseInt(node.value, 16);\r\n        }\r\n\r\n        // Received a type that doesn't need value translation\r\n        default: {\r\n            throw new Error(`Unsupported node type: ${node.type}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Encode a 16-bit hexadecimal literal or address.\r\n * @param expressionNode, the node to encode.\r\n */\r\nconst encodeHexLitorMem = expressionNode => {\r\n    const hexVal = getNodeValue(expressionNode);\r\n    const highByte = (hexVal & 0xff00) >> 8;        // Mask the top half word and store it\r\n    const lowByte = hexVal & 0x00ff;                // Store the bottom half word\r\n    machineCode.push(highByte, lowByte);            // Recall Big Endian (MSB first)\r\n}\r\n\r\n/**\r\n * Same as above for 8-bit words.\r\n * @param expressionNode, the node to encode.\r\n */\r\nconst encodeHexLit8 = expressionNode => {           \r\n    const hexVal = getNodeValue(expressionNode);\r\n    const lowByte = hexVal & 0x00ff;\r\n    machineCode.push(lowByte);\r\n}\r\n\r\n/**\r\n * Encode a register (\"index\").\r\n * @param register, the register to encode. \r\n */\r\nconst encodeReg = register => {\r\n    const mappedReg = reg[register.value.toUpperCase()];    // Get index\r\n    machineCode.push(mappedReg);\r\n}\r\n\r\n/**\r\n * Encodes the members of an 8-bit data member (array).\r\n * @param node, the node to encode.\r\n */\r\nconst encodeData8 = node => {\r\n    node.value.values.map(byte => {                     // Map and push each datum\r\n        const parsedValue = parseInt(byte.value, 16);\r\n        machineCode.push(parsedValue & 0xff);\r\n    })\r\n}\r\n/**\r\n * Encodes the members of a 16-bit data member (array).\r\n * @param node, the node to encode.\r\n */\r\nconst encodeData16 = node => {\r\n    node.value.values.map(byte => {                     // Map and push each datum\r\n        const parsedValue = parseInt(byte.value, 16);\r\n        machineCode.push((parsedValue & 0xff00) >> 8);\r\n        machineCode.push(parsedValue & 0x00ff);\r\n    })\r\n}\r\n\r\n/**\r\n * Detects if there are any name collisions between labels.\r\n * @param name string, the name to check.\r\n * @returns true if collision, false otherwise.\r\n */\r\nconst nameCollision = (name: string) => name in labels || name in structures;\r\n\r\n/**\r\n * Assembles the specified assembly code into harmonic machine code.\r\n * @param assemblyCode, the assembly code to assemble. \r\n * @returns The machine code and parsed ast.\r\n */\r\nexport const assemble = (assemblyCode) => {\r\n    // Reset storage\r\n    machineCode = [] as number[];\r\n    parsedInstructions = [];\r\n    labels = {};\r\n    structures = {};\r\n    \r\n    // Obtain parsed abstract syntax tree and filter out any comments (not labelled).\r\n    const parsedOutput = parser.run(assemblyCode);\r\n    const ast = parsedOutput.result.filter(node => typeof node !== \"string\")\r\n    \r\n    // Ensure valid parse\r\n    if (parsedOutput.isError) {\r\n        throw new Error(parsedOutput.error);\r\n    }\r\n\r\n    /*** Compiler ***/\r\n\r\n    // First, parse labels on first run so they don't need to be defined sequentially.\r\n    let currentAddress = 0;             // Keep track of address for label pointer\r\n    if (\"result\" in parsedOutput) { \r\n        ast.forEach(node => {\r\n            switch(node.type) {\r\n                case ParserTypes.LABEL: {               // Map the label with the current address. Takes no space.\r\n                    // Assert no collision\r\n                    if (nameCollision(node.value)) {\r\n                        throw new Error(\r\n                            `Can't create label \"${node.value}\" because it has already been declared.`\r\n                        )\r\n                    }\r\n\r\n                    labels[node.value] = currentAddress;        \r\n                    return;\r\n                }\r\n                    \r\n                case ParserTypes.CONSTANT: {            // Map the constant label with its value. Takes no space.\r\n                    if (nameCollision(node.value.name)) {\r\n                        throw new Error(\r\n                            `Can't create constant \"${node.value.name}\" because it has already been declared.`\r\n                        )\r\n                    }\r\n\r\n                    labels[node.value.name] = parseInt(node.value.value.value, 16) & 0xffff;\r\n                    return;\r\n                }\r\n\r\n                case ParserTypes.DATA: {                // Map the label with the current address and increment\r\n                                                        // by the number of members to be added\r\n                    if (nameCollision(node.value)) {\r\n                        throw new Error(\r\n                            `Can't create data \"${node.value}\" because it has already been declared.`\r\n                        )\r\n                    }\r\n\r\n                    labels[node.value.name] = currentAddress;\r\n                    const valueSizeInBytes = (node.value.size === 16) ? 2: 1;\r\n                    const totalBytes = node.value.values.length * valueSizeInBytes;\r\n                    currentAddress += totalBytes;\r\n                    return;\r\n                }\r\n\r\n                case ParserTypes.STRUCTURE: {           // Map the structure label to its key value pairs and \r\n                                                        // their associated offsets. Takes no space.\r\n                    if (nameCollision(node.value.name)) {\r\n                        throw new Error(\r\n                            `Can't create structure \"${node.value.name}\" because it has already been declared.`\r\n                        )\r\n                    }\r\n\r\n                    structures[node.value.name] = {\r\n                        members: {}\r\n                    };\r\n\r\n                    let offset = 0;\r\n                    node.value.members.map(({key, value}) => {\r\n                        structures[node.value.name].members[key] = {\r\n                            offset,\r\n                            size: parseInt(value.value, 16) & 0xffff\r\n                        }\r\n\r\n                        offset += structures[node.value.name].members[key].size;\r\n                    })\r\n\r\n                    return;\r\n                }\r\n\r\n                // Otherwise, it's an instruction. Update the address pointer accordingly.\r\n                default: {\r\n                    const metaData = instructionsMeta[node.value.instruction];\r\n                    currentAddress += metaData.size;\r\n                    return;\r\n                }\r\n            }\r\n        });\r\n\r\n        /**\r\n         * Checks if a given node has been accounted for by the loop abvoe.\r\n         * @param node, the node to check.\r\n         * @returns true if accounted for, false otherwise.\r\n         */\r\n        const isAccountedFor = (node) => ((node.type === ParserTypes.LABEL) || (node.type === ParserTypes.CONSTANT) || (node.type === ParserTypes.STRUCTURE));\r\n        \r\n        // Now start encoding the parsed tree into machine code\r\n        let pointerIndex = 0;   // Keep track of address for parsed instruction list (for client)\r\n        ast.forEach(node => {\r\n\r\n            if (isAccountedFor(node)) { return; }                   // Avoid double parsing\r\n            else if (node.type === ParserTypes.DATA) {              // Encode data\r\n                if (node.value.size === 8) {\r\n                    encodeData8(node);\r\n                } else {\r\n                    encodeData16(node);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // It's a instruction, update the address by + size\r\n            const metaData = instructionsMeta[node.value.instruction];\r\n            machineCode.push(metaData.opCode);\r\n\r\n            // Update instruction tree with instruction and address (for client).\r\n            parsedInstructions.push({\r\n                instruction: metaData.instruction,\r\n                args: node.value.args.map(arg => {\r\n                    if (isNaN(parseInt(arg.value))) return arg.value\r\n                    return `0x${arg.value.toString(16).padStart(4, \"0\")}`;\r\n                }),\r\n                index: pointerIndex\r\n            })\r\n            pointerIndex += metaData.size;\r\n\r\n            /** Encode each generic parsed instruction accordingly **/\r\n            if ([I.litReg, I.memReg].includes(metaData.type)) {\r\n                encodeHexLitorMem(node.value.args[0]);\r\n                encodeReg(node.value.args[1]);\r\n            } \r\n            else if ([I.regLit, I.regMem].includes(metaData.type)) {\r\n                encodeReg(node.value.args[0]);\r\n                encodeHexLitorMem(node.value.args[1]);\r\n            }\r\n            else if (I.regLit8 === metaData.type) {\r\n                encodeReg(node.value.args[0]);\r\n                encodeHexLit8(node.value.args[1]);\r\n            }\r\n            else if ([I.regReg, I.regIndReg].includes(metaData.type)) {\r\n                encodeReg(node.value.args[0]);\r\n                encodeReg(node.value.args[1]);\r\n            }\r\n            else if(I.litMem === metaData.type) {\r\n                encodeHexLitorMem(node.value.args[0]);\r\n                encodeHexLitorMem(node.value.args[1]);\r\n            }\r\n            else if (I.litOffReg === metaData.type) {\r\n                encodeHexLitorMem(node.value.args[0]);\r\n                encodeReg(node.value.args[1]);\r\n                encodeReg(node.value.args[2]);\r\n            }\r\n            else if (I.singleReg === metaData.type) {\r\n                encodeReg(node.value.args[0]);\r\n            }\r\n            else if (I.singleLit === metaData.type) {\r\n                encodeHexLitorMem(node.value.args[0]);\r\n            } else { \r\n                // No args\r\n            }\r\n        })\r\n    }\r\n    return { assembled: machineCode, parsedInstructions };\r\n};\r\n","import React, { forwardRef, useImperativeHandle, useRef, useState } from \"react\";\r\nimport { assemble } from \"../harmonic/src/assembler\";\r\nimport { initMachine, setMeta } from \"../reducers/memoryReducer\";\r\nimport { useAppDispatch } from \"../store\";\r\nimport { ToastContainer } from \"react-toastify\";\r\nimport { toastSuccess, toastError, dismissAll } from \"./toasts\";\r\n\r\nimport Monaco from \"@monaco-editor/react\";\r\nimport useHarmonic from \"./language\";\r\nimport ProgramMeta from \"./ProgramMeta\";\r\n\r\n// The editor tab: either assembly or machine code\r\nenum EditorType {\r\n    ASSEMBLY=\"ASSEMBLY\",\r\n    MACHINE_CODE=\"MACHINE_CODE\"\r\n};\r\ntype EditorProps = { setDisableAssemble: (arg: boolean) => void };\r\n\r\n/**\r\n * Code Editor component that support editing and highlighting \r\n * of harmonic assembly and machine code.\r\n * @param props \r\n * @param ref, forward ref to expose inner methods to navbar (bad).\r\n * @returns JSX.Element, the editor component.\r\n */\r\nconst Editor = (props: EditorProps, ref) => {\r\n    const dispatch = useAppDispatch();                              // Type global state dispatch\r\n    const assemblyCode = useRef(\"\");                                // Stores assembly code\r\n    const machineCode = useRef(\"\");                                 // Stores machine code hex\r\n    const [editor, setEditor] = useState(EditorType.ASSEMBLY);      // Stores current editor tab\r\n    const editorRef = useRef(null);                                 // Editor ref to load monaco instance and reference text\r\n    const languageID = useHarmonic();                               // Language hook to use my syntax highlighting :)\r\n\r\n    /**\r\n     * Saves the current assembly code to state\r\n     */\r\n    const saveAssembly = () => assemblyCode.current = editorRef.current.getValue();\r\n\r\n    /**\r\n     * Replace \\r\\n with \\n for comment parsing since regex is hard\r\n     * @param text string, the text to format.\r\n     * @returns string, the formatted text.\r\n     */\r\n    const format = (text: string): string => text.replace(/(?:\\r\\n|\\r|\\n)/g, '\\n'); \r\n\r\n    /**\r\n     * Sets editor tab status and disables \"assemble\" instruction if editing machine code.\r\n     * Loading doesn't cause errors while writing assembly\r\n     * @param type EditorType, the current tab to set.\r\n     */\r\n    const setEditorWrapped = (type: EditorType) => {\r\n        props.setDisableAssemble(type == EditorType.MACHINE_CODE);\r\n        setEditor(type);\r\n    }\r\n\r\n    /**\r\n     * Parses the current assembly code and generates the corresponding machine code.\r\n     * @param base number, the base pointer at assemble time (presumably where this will be loaded).\r\n     *                     This is used to index the program meta.\r\n     * @param reset boolean, false if we're adding to the previous memory state. False otherwise.\r\n     */\r\n    const generateMachineCode = (base: number, reset: boolean) => {\r\n        dismissAll();       // Dismiss toasts\r\n        saveAssembly();     // Save the current written code\r\n\r\n        let assembled: number[], parsedInstructions: any[];\r\n        // Attempt to acquire parsed machine code\r\n        try {\r\n            // Display success toast on success\r\n            ({ assembled, parsedInstructions } = assemble(format(assemblyCode.current.trim() + \"\\n\")));\r\n            toastSuccess(\"Successful Assembly!\");\r\n        } catch (e) {\r\n            // Display error on failure\r\n            toastError(e.message);\r\n            return;\r\n        }\r\n\r\n        // If we succeed, format the machine code as a series \r\n        // of hex bytes to display in the editor\r\n        machineCode.current = assembled.reduce((code, byte, _) => {\r\n            code += `0x${byte.toString(16).padStart(2, \"0\")}` + \" \";\r\n            return code;\r\n        }, \"\");\r\n\r\n        dispatch(setMeta({meta: parsedInstructions, base, reset}));     // Update the program meta, indexed by assemble-time base\r\n        setEditorWrapped(EditorType.MACHINE_CODE);                      // Switch to machine code editor tab\r\n    }\r\n\r\n    /**\r\n     * Loads the binary machine code into the vm following the specified base address.\r\n     * @param base number, the address to begin loading at.\r\n     * @param reset boolean, false if we're adding to the previous memory state. False otherwise.\r\n     */\r\n    const loadBinary = (base: number, reset: boolean) =>{ \r\n        const binaryBuffer = machineCode.current.split(\" \").map(byte => parseInt(byte, 16));\r\n        dispatch(initMachine({program: binaryBuffer, base, reset}));\r\n    }\r\n\r\n    // Forward generate and load methods so they can be referenced from the nav \r\n    // (not best practice - should be defined outside).\r\n    useImperativeHandle(ref, () => ({\r\n        generateMachineCode (base: number, reset: boolean) {\r\n            generateMachineCode(base, reset);\r\n        },\r\n        loadBinary (base: number, reset: boolean) {\r\n            loadBinary(base, reset);\r\n        }\r\n    }), []);\r\n\r\n    // Wait until harmonic definition is loaded.\r\n    if (!languageID) { return null; }\r\n\r\n    // Set the ref on editor mount.\r\n    const handleEditorDidMount = (editor, _) => {\r\n        editorRef.current = editor;\r\n    }\r\n\r\n    return (\r\n        <>\r\n        <ToastContainer />\r\n        <div className=\"tab-area\">\r\n            <button className={(editor === EditorType.ASSEMBLY) ? \"editor-tab active\" : \"editor-tab\"} onClick={() => setEditorWrapped(EditorType.ASSEMBLY)}>Assembly</button>\r\n            <button disabled={!machineCode.current} className={(editor === EditorType.MACHINE_CODE) ? \"editor-tab active\" : \"editor-tab\"} onClick={() => setEditorWrapped(EditorType.MACHINE_CODE)}>Loader</button>\r\n        </div>\r\n        <div className=\"editor\">\r\n            <Monaco \r\n                height={(editor === EditorType.ASSEMBLY) ? \"80%\" : \"50%\"}\r\n                value={(editor === EditorType.ASSEMBLY) ? assemblyCode.current : machineCode.current}\r\n                onChange={ saveAssembly }\r\n                language={ languageID }\r\n                onMount={ handleEditorDidMount }\r\n                options={{\"fontSize\": 15, \"mouseWheelZoom\": true}}\r\n                theme=\"vs-dark\"\r\n            />       \r\n            {\r\n                (editor === EditorType.MACHINE_CODE) &&\r\n                <div style={{height: \"44%\"}}>\r\n                    <ProgramMeta />\r\n                </div>\r\n            }     \r\n        </div>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default forwardRef(Editor);\r\n","import styled from \"styled-components\";\r\n\r\n/*** Styles for prisma syntax highlighting (css is not supported conviently) ***/\r\n\r\nexport const Wrapper = styled.div`\r\n  font-family: sans-serif;\r\n  text-align: center;\r\n`;\r\n\r\nexport const Pre = styled.pre`\r\n  text-align: left;\r\n  height: 100%;\r\n  margin: 0;\r\n  padding: 0.5em;\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  white-space: normal\r\n\r\n  & .token-line {\r\n    line-height: 1.3em;\r\n    height: 1.3em;\r\n  }\r\n`;\r\n\r\nexport const Line = styled.div`\r\n  display: table-row;\r\n`;\r\n\r\nexport const LineNo = styled.span`\r\n  display: table-cell;\r\n  text-align: right;\r\n  padding-right: 1em;\r\n  user-select: none;\r\n  opacity: 0.5;\r\n`;\r\n\r\nexport const LineContent = styled.span`\r\n  display: table-cell;\r\n`;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport { Pre, Line, LineNo, LineContent } from \"./styles\";\r\nimport Highlight, { defaultProps } from \"prism-react-renderer\";\r\nimport { useAppSelector } from \"../store\";\r\nimport { metaSelector, pcSelector } from \"../reducers/memoryReducer\";\r\nimport \"./memoryStyles.css\";\r\nimport { Scrollbars } from 'react-custom-scrollbars';\r\nimport { Select } from \"@chakra-ui/react\";\r\n\r\n/**\r\n * ProgramMeta component that highlights the parsed and stored\r\n * instructions (i.e the abstract syntax tree) using Prisma.\r\n * @returns JSX.Element, the ProgramMeta component.\r\n */\r\nconst ProgramMeta = () => {\r\n    const [base, setBase] = useState<string | null>(\"0\");   // The base address to display meta for (incase of subroutines)\r\n    const instructions = useAppSelector(metaSelector);      // The abstract syntax tree in state (as sequential array of instructions )\r\n    const pc = useAppSelector(pcSelector);                  // Current pc value -> highlight pointed instruction\r\n\r\n    /**\r\n     * Highlight the current instruction that pc is pointing at\r\n     */\r\n    useEffect(() => {\r\n        const pcLine = document.getElementsByClassName(`line-0x${pc.toString(16).padStart(4, \"0\")}`);\r\n\r\n        let pcElem;\r\n        if (pcLine[0]) {\r\n            pcElem = pcLine[0];\r\n            pcElem.classList.add('pointed-pc-line');\r\n        }\r\n\r\n        return () => {\r\n            pcElem?.classList.remove('pointed-pc-line');\r\n        }\r\n    })\r\n\r\n    /** Create the instruction list */\r\n\r\n    // Assert we have parsed instructions to display.\r\n    if (!instructions) { return null; }\r\n    // If instruction at base doesn't exist, default to first address.\r\n    if (!instructions[base]) { setBase(Object.keys(instructions)[0]); return null; }\r\n    // Assert that instructions at base exist.\r\n    if (!instructions[base].length) { return null; }\r\n\r\n    // Format the instructions as a string to be displayed \r\n    const exampleCode = instructions[base].map(instruction => (\r\n        `${instruction.instruction} \\t` + instruction.args.reduce((argString, arg, idx) => {    // Add a tab following mnemonic\r\n            const punctuation = (idx === instruction.args.length - 1) ? \"\" : \",\"                // Comma after first arg\r\n            argString += `${arg}${punctuation} `;\r\n            return argString;\r\n        }, \"\")\r\n    )).join(\"\\n\");  \r\n\r\n\r\n    // Render thumb for scrollbar \r\n    const renderThumb = ({ style, ...props }) => {\r\n      const thumbStyle = {\r\n          backgroundColor: 'rgba(255, 255, 255, 0.1)'\r\n      };\r\n      return (\r\n          <div\r\n              style={{ ...style, ...thumbStyle, borderRadius: '10px' }}\r\n              {...props}/>\r\n      );\r\n    };\r\n\r\n    return (\r\n        <div style={{height: \"100%\", width: \"100%\", position: \"relative\"}}>\r\n          <Select\r\n            position={\"relative\"}\r\n            left={\"calc(100% - 160px)\"}\r\n            zIndex={2}\r\n            width={40}\r\n            height={10}\r\n            marginTop={-10}\r\n            marginBottom={-10}\r\n            bg='#272430'\r\n            borderColor='#272430'\r\n            color='#9A86EA'\r\n            fontFamily={\"SFMono-Regular,Menlo,Monaco,Consolas,monospace;\"}\r\n            defaultValue={Object.keys(instructions)[0]}\r\n            onChange={e => setBase(e.target.value)}\r\n          >\r\n              {\r\n                // Line numbers as hexadecimal address\r\n                Object.keys(instructions).map((instructionBase, idx) => \r\n                  <option key={idx} value={instructionBase}>{`0x${parseInt(instructionBase, 16).toString(16).padStart(4, \"0\")}`}</option>\r\n                )\r\n              }\r\n          </Select>\r\n          <Highlight\r\n            {...defaultProps}\r\n            code={exampleCode}\r\n            language=\"jsx\"\r\n          >\r\n            {({ className, style, tokens, getLineProps, getTokenProps }) => (\r\n                <Pre className={className} style={{...style}}>\r\n                  <Scrollbars\r\n                    autoHide\r\n                    autoHideTimeout={1000}        \r\n                    autoHideDuration={500}\r\n                    renderThumbVertical={renderThumb}\r\n                    renderView={\r\n                      () => <div style={{\r\n                          display: \"flex\", \r\n                          flexDirection: \"column\",\r\n                          position: \"absolute\",\r\n                          inset: \"0px\",\r\n                          overflow: \"scroll\",\r\n                          marginRight: \"-17px\",\r\n                          marginBottom: \"-17px\",\r\n                          paddingBottom: \"100px\"\r\n                        }}></div>\r\n                    }\r\n                  >\r\n                  {tokens.map((line, index) => {      // Display each line\r\n                    const lineProps = getLineProps({ line, key: index });\r\n                    lineProps.className += ` line-${`0x${instructions[base][index].index.toString(16).padStart(4, \"0\")}`}`;\r\n                    \r\n                    return (\r\n                      <Line key={index} {...lineProps} >\r\n                        <LineNo>{`0x${instructions[base][index].index.toString(16).padStart(4, \"0\")}`}</LineNo>\r\n                        <LineContent>\r\n                          {line.map((token, key) => (\r\n                            <span style={{\r\n                                width: 180,\r\n                                minWidth: 180,\r\n                                maxWidth: 180\r\n                            }} key={key} {...getTokenProps({ token, key })} />\r\n                          ))}\r\n                        </LineContent>\r\n                      </Line>\r\n                    );\r\n                  })}\r\n                  </Scrollbars>\r\n                </Pre>\r\n              )}\r\n          </Highlight>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ProgramMeta;","import { useMonaco } from \"@monaco-editor/react\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { InstructionMnemonic } from \"../harmonic/src/cpu/instructions\";\r\n\r\n/**\r\n * Hook that defines the harmonic language for syntax highlighting.\r\n */\r\nexport default function useHarmonic() {\r\n    const monaco = useMonaco();\r\n    const [languageID, setLanguageID] = useState(\"\");\r\n\r\n    // Set instructions as keywords in both cases\r\n    const keywords = Object.values(InstructionMnemonic)\r\n        .filter(value => typeof value === \"string\")\r\n        .reduce((arr, keyword) => {\r\n            arr.push(keyword);\r\n            arr.push(keyword.toUpperCase());\r\n            return arr;\r\n        }, []);\r\n\r\n    // All register tags match for regex.\r\n    const regs = /(r0|R0|r1|R1|r2|R2|r3|R3|r4|R4|r5|R5|r6|R6|r7|R7|acc|ACC|mb|MB|im|IM|sp|SP|fp|FP|pc|PC)/;\r\n\r\n    useEffect(() => {\r\n        if (!monaco) { return; }\r\n\r\n        const languageID = \"harmonic\";\r\n        setLanguageID(languageID);\r\n\r\n        monaco.languages.register({ id: languageID });\r\n\r\n        // Define tokens\r\n        monaco.languages.setMonarchTokensProvider(\"harmonic\",{\r\n            defaultToken: \"invalid\",\r\n            keywords,\r\n            typeKeywords: ['constant', 'data8', 'data16', 'structure'],\r\n            operators: ['+', \"-\", \"/\", \"*\", \"!\"],\r\n            \r\n            // Common regular expressions\r\n            symbols:  /[=><!~?:&|+\\-*\\/\\^%]+/,\r\n            escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\r\n            hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\r\n\r\n            tokenizer: {\r\n                root: [\r\n                    [regs, \"number.register\"],                  // Registers\r\n                    [/\\$(@hexdigits)/, 'string.invalid'],       // Hex Literals\r\n                    [/\\&(@hexdigits)/, 'number.addr'],          // Addresses\r\n\r\n                    // identifiers and keywords\r\n                    [/[a-z_$][\\w$]*/, { \r\n                        cases: { '@typeKeywords': 'keyword',\r\n                                   '@keywords': 'keyword',\r\n                                   '@default': 'identifier' } \r\n                    }],\r\n                    // whitespace\r\n                    { include: '@whitespace' },\r\n                    [/[A-Z][\\w\\$]*/, 'type.identifier' ],      \r\n                    [/\\!\\s*[a-zA-Z_\\$][\\w\\$]*/, { token: 'annotation', log: 'annotation token: $0' }],  // Variables: !loc\r\n\r\n                    [/\\[(.*)\\]/, \"type.identifier\"],                // Bracketed expressions []\r\n\r\n                    // delimiters and operators\r\n                    [/[{}()\\[\\]]/, '@brackets'],\r\n                    [/[<>](?!@symbols)/, '@brackets'],\r\n\r\n                    // numbers\r\n                    [/\\[(.*?)\\]/, 'number.literal']\r\n                ],\r\n                whitespace: [\r\n                    [/[ \\t\\r\\n]+/, ''],\r\n                    [/(^;.*$)/, 'comment']                          // Comments\r\n                ]\r\n            }\r\n        }); \r\n    }, [monaco]);\r\n\r\n    // Loaded when this returns\r\n    if (languageID !== \"\") {\r\n        return languageID;\r\n    }\r\n}","import { toast } from \"react-toastify\";\r\nimport 'react-toastify/dist/ReactToastify.css';\r\n\r\n/*** Wrapped Toast Methods ***/\r\n\r\n/**\r\n * Closes/dismisses all active toasts.\r\n */\r\nconst dismissAll = () => toast.dismiss();\r\n\r\n/**\r\n * Displays a success toast.\r\n * @param message string, the message to display.\r\n */\r\nconst toastSuccess = (message: string) =>  toast.success(message, {\r\n    position: \"bottom-right\",\r\n    autoClose: 1000,\r\n    closeOnClick: true,\r\n    pauseOnHover: true,\r\n    draggable: true,\r\n    theme: \"dark\",\r\n    style: {fontSize: 13}\r\n});\r\n\r\n/**\r\n * Displays an error toast.\r\n * @param message string, the message to display.\r\n */\r\nconst toastError = (message: string) => toast.error(message, {\r\n    position: \"top-right\",\r\n    autoClose: 5000,\r\n    hideProgressBar: true,\r\n    closeOnClick: true,\r\n    pauseOnHover: true,\r\n    draggable: true,\r\n    progress: undefined,\r\n    theme: \"dark\",\r\n    style: {fontSize: 13}\r\n});\r\n\r\nexport { dismissAll, toastSuccess, toastError };\r\n","import React from \"react\";\r\nimport { Box, Text } from \"@chakra-ui/react\";\r\n\r\n/**\r\n * Linear Gradient Harmonic Logo\r\n */\r\nconst Logo = (props: any) => (\r\n    <Box { ...props }>\r\n        <Text\r\n            bgGradient=\"linear(to-l, blue.200, teal.500)\"\r\n            bgClip=\"text\"\r\n            fontSize=\"20\" fontWeight=\"extrabold\"\r\n        >\r\n            Harmonic\r\n        </Text>\r\n    </Box>\r\n);\r\n\r\nexport default Logo;","import React from \"react\";\r\nimport { Slider, SliderFilledTrack, SliderMark, SliderThumb, SliderTrack, Tooltip } from \"@chakra-ui/react\"\r\n\r\n/**\r\n * Slider to modify run step speed\r\n * @param onChange handler, onChange handler for speed\r\n * @param open boolean, controls if tooltip opens\r\n */\r\nconst SpeedSlider = ({onChange, open}) => {\r\n    const [sliderValue, setSliderValue] = React.useState(5);\r\n    const [showTooltip, setShowTooltip] = React.useState(false);\r\n\r\n    return (\r\n      <Slider\r\n        id='slider'\r\n        defaultValue={5}\r\n        min={20}\r\n        max={100}\r\n        width={150}\r\n        colorScheme='teal'\r\n        onChange={(v) => { setSliderValue(v); onChange(v); }}\r\n        onMouseEnter={() => setShowTooltip(true)}\r\n        onMouseLeave={() => setShowTooltip(false)}\r\n      >\r\n        <Tooltip\r\n          bg='blue.600'\r\n          color='white'\r\n          placement='top-start'\r\n          isOpen={open}\r\n          label={`Running Speed`}\r\n        > </Tooltip>\r\n        <SliderMark value={25} mt='1' ml='-2.5' fontSize='sm'>\r\n          25%\r\n        </SliderMark>\r\n        <SliderMark value={50} mt='1' ml='-2.5' fontSize='sm'>\r\n          50%\r\n        </SliderMark>\r\n        <SliderMark value={75} mt='1' ml='-2.5' fontSize='sm'>\r\n          75%\r\n        </SliderMark>\r\n        <SliderTrack>\r\n          <SliderFilledTrack />\r\n        </SliderTrack>\r\n        <Tooltip\r\n          hasArrow\r\n          bg='teal.500'\r\n          color='white'\r\n          placement='top'\r\n          isOpen={showTooltip}\r\n          label={`${sliderValue}%`}\r\n        >\r\n          <SliderThumb />\r\n        </Tooltip>\r\n      </Slider>\r\n    )\r\n  };\r\n\r\nexport default SpeedSlider;","import React from \"react\";\r\nimport { Link, Box, Flex, Text, Button, Stack, useColorMode, Input, FormLabel, Checkbox } from \"@chakra-ui/react\";\r\nimport Logo from \"./Logo\";\r\nimport SpeedSlider from \"./SpeedSlider\";\r\n\r\n/**\r\n * Navbar container wrapper\r\n * @param props handlerFunctions, see MenuLinks.\r\n */\r\nconst NavBar = (props) => {\r\n  const [isOpen, setIsOpen] = React.useState(true);\r\n  const toggle = () => setIsOpen(!isOpen);\r\n\r\n  return (\r\n    <NavBarContainer {...props}>\r\n      <Logo/>\r\n      <MenuToggle toggle={toggle} isOpen={isOpen} />\r\n      <MenuLinks {...props} isOpen={isOpen} />\r\n    </NavBarContainer>\r\n  );\r\n};\r\n\r\n/**\r\n * Burger Close Icon\r\n */\r\nconst CloseIcon = () => (\r\n  <svg width=\"24\" viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\">\r\n    <title>Close</title>\r\n    <path\r\n      fill=\"white\"\r\n      d=\"M9.00023 7.58599L13.9502 2.63599L15.3642 4.04999L10.4142 8.99999L15.3642 13.95L13.9502 15.364L9.00023 10.414L4.05023 15.364L2.63623 13.95L7.58623 8.99999L2.63623 4.04999L4.05023 2.63599L9.00023 7.58599Z\"\r\n    />\r\n  </svg>\r\n);\r\n\r\n/**\r\n * Burger Menu Icon\r\n */\r\nconst MenuIcon = () => (\r\n  <svg\r\n    width=\"24px\"\r\n    viewBox=\"0 0 20 20\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n    fill=\"white\"\r\n  >\r\n    <title>Menu</title>\r\n    <path d=\"M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0v-2z\" />\r\n  </svg>\r\n);\r\n\r\n/**\r\n * Burger Menu Toggle Button\r\n */\r\nconst MenuToggle = ({ toggle, isOpen }) => {\r\n  return (\r\n    <Box display={{ base: \"block\", md: \"none\" }} onClick={toggle}>\r\n      {isOpen ? <CloseIcon /> : <MenuIcon />}\r\n    </Box>\r\n  );\r\n};\r\n\r\n/**\r\n * Navigation Link (Emulates a button)\r\n */\r\nconst MenuAButton = ({ children, to = \"/\", ...rest }) => {\r\n  return (\r\n      <Text cursor=\"pointer\" display=\"block\" {...rest}>\r\n        {children}\r\n      </Text>\r\n  );\r\n};\r\n\r\n/**\r\n * All the navigation links\r\n */\r\nconst MenuLinks = ({ isOpen, handleAssemble, handleLoadBinary, handleStep, handleRun, handleRunSpeed, disabledAssemble, running }) => {\r\n  const { colorMode, toggleColorMode } = useColorMode();  // Handles theme\r\n  const baseAddr = React.useRef(0);                       // Load base address\r\n  const fresh = React.useRef(false);                      // True if loading and refreshing internal memory state, false otherwise\r\n\r\n  return (\r\n    <Box\r\n      display={{ base: isOpen ? \"block\" : \"none\", md: \"block\" }}\r\n      flexBasis={{ base: \"100%\", md: \"auto\" }}\r\n    >\r\n      <Stack\r\n        spacing={8}\r\n        align=\"center\"\r\n        justify={[\"center\", \"space-between\", \"flex-end\", \"flex-end\"]}\r\n        direction={[\"column\", \"column\", \"row\", \"row\"]}\r\n        pt={[4, 4, 0, 0]}\r\n      >\r\n        <MenuAButton \r\n          color={disabledAssemble ? \"grey\" : \"inherit\"}\r\n          _hover={{\r\n            color: disabledAssemble ? \"grey\" : \"teal.500\",\r\n            cursor: disabledAssemble ? \"default\" : \"pointer\",\r\n            transition: \"100ms ease\"\r\n          }} \r\n          onClick={() => !disabledAssemble && handleAssemble(baseAddr.current, fresh.current)}> Assemble </MenuAButton>\r\n        <FormLabel \r\n          htmlFor='load' \r\n          _hover={{\r\n            color: \"teal.500\",\r\n            transition: \"100ms ease\",\r\n            cursor: \"pointer\"\r\n          }} \r\n          onClick={() => handleLoadBinary(baseAddr.current, fresh.current)}\r\n        >\r\n          Load\r\n        </FormLabel>\r\n        <Checkbox\r\n          onChange={e => fresh.current = e.target.checked}\r\n        >\r\n          Fresh?\r\n        </Checkbox>\r\n        <Input \r\n            id=\"load\"\r\n            defaultValue={\"0000\"}\r\n            color={\"blue.600\"}\r\n            fontWeight={\"bold\"} \r\n            maxLength={4} \r\n            height={\"30px\"}\r\n            width={\"60px\"}\r\n            fontSize={\"18px\"} \r\n            padding={\"5px\"}\r\n            onChange={event => baseAddr.current = parseInt(event.target.value, 16)}\r\n        ></Input>\r\n        <MenuAButton \r\n          _hover={{\r\n            color: \"teal.500\",\r\n            transition: \"100ms ease\"\r\n          }} \r\n          onClick={handleStep}> Step </MenuAButton>\r\n        <SpeedSlider open={isOpen} onChange={(value) => handleRunSpeed(value)}></SpeedSlider>\r\n        <MenuAButton>\r\n          <Button\r\n            size=\"sm\"\r\n            rounded=\"md\"\r\n            color={[\"white\", \"white\", \"white\", \"white\"]}\r\n            bg={[\"blue.600\", \"blue.600\", \"blue.600\", \"blue.600\"]}\r\n            _hover={{\r\n              bg: [\"teal.500\", \"teal.500\", \"teal.500\", \"teal.500\"]\r\n            }}\r\n            onClick={handleRun}\r\n          >\r\n            { running ? \"Stop\" : \"Run\" }\r\n          </Button>\r\n        </MenuAButton>\r\n        <MenuAButton>\r\n          <Button\r\n            size=\"sm\"\r\n            rounded=\"md\"\r\n            color={[\"white\", \"white\", \"white\", \"white\"]}\r\n            bg={[\"blue.600\", \"blue.600\", \"blue.600\", \"blue.600\"]}\r\n            _hover={{\r\n              bg: [\"teal.500\", \"teal.500\", \"teal.500\", \"teal.500\"]\r\n            }}\r\n            onClick={toggleColorMode}\r\n          >\r\n            Toggle {colorMode === \"light\" ? \"Dark\" : \"Light\"}\r\n          </Button>\r\n        </MenuAButton>\r\n      </Stack>\r\n    </Box>\r\n  );\r\n};\r\n\r\n/**\r\n * Navbar container\r\n */\r\nconst NavBarContainer = ({ children, ...props }) => {\r\n  return (\r\n    <Flex\r\n      as=\"nav\"\r\n      align=\"center\"\r\n      justify=\"space-between\"\r\n      wrap=\"wrap\"\r\n      w=\"100%\"\r\n      mb={8}\r\n      p={8}\r\n      bg=\"#243447\"\r\n      color=\"white\"\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Flex>\r\n  );\r\n};\r\n\r\nexport default NavBar;","import ProgramTables from './components/ProgramTables';\nimport Editor from './components/Editor';\nimport \"./App.scss\";\nimport { useEffect, useRef, useState } from 'react';\nimport { useAppDispatch, useAppSelector } from './store';\nimport { haltSelector, step, resetHalt } from './reducers/memoryReducer';\nimport NavBar from './components/nav/Header';\n\nconst DEFAULT_SPEED = 20;\nconst App = () => {\n  const dispatch = useAppDispatch();\n  const [running, setRunning] = useState(false);\n  const [disableAssemble, setDisableAssemble] = useState(false);\n  const runSpeed = useRef<number>(DEFAULT_SPEED);\n  const editorRef = useRef<any>();\n  const runIntervalId = useRef<any>(null);\n  const halt = useAppSelector(haltSelector);\n\n  useEffect(() => {\n    if (halt && runIntervalId.current) clearInterval(runIntervalId.current);\n  }, [halt]);\n\n\n  /**\n   * Sets up interval to step through\n   * each loaded instruction\n   */\n  const SLOW = 1000;\n  const FAST = 50;\n  const handleRun = () => {\n    const wasRunning = running;\n\n    setRunning(!running);\n\n    if (wasRunning) {\n      clearInterval(runIntervalId.current);\n      runIntervalId.current = null;\n      return;\n    }\n\n    dispatch(resetHalt());\n\n    // Range slow (1000) to fast (50)\n    const speed = SLOW - (runSpeed.current / 100) * (SLOW - FAST);\n    runIntervalId.current = setInterval(() => {\n       dispatch(step())\n    }, speed); // 500 should be bound to slider\n  }\n\n  const handleRunSpeed = (value: number) => runSpeed.current = value;\n\n  return (\n    <div className=\"body-wrapper\">\n      <NavBar \n        handleAssemble={(base: number, reset: boolean = false) => editorRef.current && editorRef.current.generateMachineCode(base, reset)}\n        handleLoadBinary={(base: number, reset: boolean = false) => editorRef.current && editorRef.current.loadBinary(base, reset)}\n        disabledAssemble={disableAssemble}\n        handleStep={() => dispatch(step())}\n        handleRun={() => handleRun()}\n        handleRunSpeed={(newSpeed: number) => handleRunSpeed(newSpeed)}\n        running={running}\n      />\n\n      <div className=\"app-wrapper\">\n          <div className=\"editor\">   \n            <Editor ref={editorRef} setDisableAssemble={setDisableAssemble}/>\n          </div>\n          <div className=\"program-tables\">\n            <ProgramTables />\n          </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store } from \"./store\";\nimport { ChakraProvider, ColorModeScript, ThemeProvider } from \"@chakra-ui/react\";\nimport theme from \"./components/theme/theme\";\n\nimport App from './App';\n\nReactDOM.render(\n  <ChakraProvider>\n    <ThemeProvider theme={theme}>\n      <Provider store={store}>\n        <ColorModeScript initialColorMode={theme.config.initialColorMode} />\n        <App />\n      </Provider>\n    </ThemeProvider>\n  </ChakraProvider>,\n  document.getElementById('root')\n);\n\n","/**\r\n * Instruction Types and Formats\r\n */\r\n\r\n// A list of all the register formats (should've named it formats :/)\r\nexport enum InstructionTypes {\r\n    litReg=\"litReg\",\r\n    regLit=\"regLit\",\r\n    regLit8=\"regLit8\",\r\n    regReg=\"regReg\",\r\n    regMem=\"regMem\",\r\n    memReg=\"memReg\", \r\n    litMem=\"litMem\",\r\n    regIndReg=\"regIndReg\",\r\n    litOffReg=\"litOffReg\",\r\n    noArgs=\"noArgs\",\r\n    singleReg=\"singleReg\",\r\n    singleLit=\"singleLit\"\r\n};\r\n\r\n// Corresponds to the formats above, the size of \r\n// each instruction in bytes (for parsing)\r\ntype InstructionSize = {[key in InstructionTypes]: number };\r\nconst instructionSize: InstructionSize = {\r\n    [InstructionTypes.litReg]: 4,\r\n    [InstructionTypes.regLit]: 4,\r\n    [InstructionTypes.regLit8]: 3,\r\n    [InstructionTypes.regReg]: 3,\r\n    [InstructionTypes.regMem]: 4,\r\n    [InstructionTypes.memReg]: 4,\r\n    [InstructionTypes.litMem]: 5,\r\n    [InstructionTypes.regIndReg]: 3,\r\n    [InstructionTypes.litOffReg]: 5,\r\n    [InstructionTypes.noArgs]: 1,\r\n    [InstructionTypes.singleReg]: 2,\r\n    [InstructionTypes.singleLit]: 3,\r\n}\r\n\r\n// Symbols corresponding to each type of instruction\r\nexport enum InstructionMnemonic {\r\n    MOV=\"mov\",\r\n    // LDR=\"ldr\",\r\n    // STR=\"str\",\r\n    \r\n    ADD=\"add\",\r\n    SUB=\"sub\",\r\n    MUL=\"mul\",\r\n    OR=\"or\",\r\n    AND=\"and\",\r\n    XOR=\"xor\",\r\n    NOT=\"not\",\r\n\r\n    LSL=\"lsl\",\r\n    LSR=\"lsr\",\r\n\r\n    INC=\"inc\",\r\n    DEC=\"dec\",\r\n\r\n    JNE=\"jne\",\r\n    JEQ=\"jeq\",\r\n    JLT=\"jlt\",\r\n    JGT=\"jgt\",\r\n    JLE=\"jle\",\r\n    JGE=\"jge\",\r\n\r\n    PSH=\"psh\",\r\n    POP=\"pop\",\r\n    CAL=\"cal\",\r\n    RET=\"ret\",\r\n    HLT=\"hlt\",\r\n    INT=\"int\",\r\n    RET_INT=\"rti\"\r\n};\r\n\r\n// All the supported instructions\r\nexport enum Instruction {\r\n    MOV_LIT_RD=         \"MOV_LIT_RD\",\r\n    MOV_RS_RD=          \"MOV_RS_RD\",\r\n    STR_RS_MEM=         \"STR_RS_MEM\",\r\n    LDR_MEM_RD=         \"LDR_MEM_RD\",\r\n    STR_LIT_MEM=        \"STR_LIT_MEM\",\r\n    LDR_REG_IND_REG=    \"LDR_REG_IND_REG\",\r\n    LDR_LIT_OFF_REG=    \"LDR_LIT_OFF_REG\",\r\n    \r\n    ADD_RX_RY=          \"ADD_RX_RY\",\r\n    ADD_LIT_REG=        \"ADD_LIT_REG\",\r\n    SUB_REG_LIT=        \"SUB_REG_LIT\",\r\n    SUB_LIT_REG=        \"SUB_LIT_REG\",\r\n    SUB_RX_RY=          \"SUB_RX_RY\",\r\n    INC_REG=            \"INC_REG\",\r\n    DEC_REG=            \"DEC_REG\",\r\n    MUL_LIT_REG=        \"MUL_LIT_REG\",\r\n    MUL_REG_REG=        \"MUL_REG_REG\",\r\n\r\n    LSL_REG_LIT=        \"LSL_REG_LIT\",\r\n    LSL_REG_REG=        \"LSL_REG_REG\",\r\n    LSR_REG_LIT=        \"LSR_REG_LIT\",\r\n    LSR_REG_REG=        \"LSR_REG_REG\",\r\n    AND_REG_LIT=        \"AND_REG_LIT\",   \r\n    AND_REG_REG=        \"AND_REG_REG\",\r\n    OR_REG_LIT=         \"OR_REG_LIT\",\r\n    OR_REG_REG=         \"OR_REG_REG\",\r\n    XOR_REG_LIT=        \"XOR_REG_LIT\",\r\n    XOR_REG_REG=        \"XOR_REG_REG\",\r\n    NOT=                \"NOT\",   \r\n\r\n    JMP_NOT_EQ=         \"JMP_NOT_EQ\",\r\n    JNE_REG=            \"JNE_REG\",\r\n    JEQ_REG=            \"JEQ_REG\",\r\n    JEQ_LIT=            \"JEQ_LIT\",\r\n    JLT_REG=            \"JLT_REG\",   \r\n    JLT_LIT=            \"JLT_LIT\",\r\n    JGT_REG=            \"JGT_REG\",\r\n    JGT_LIT=            \"JGT_LIT\",\r\n    JLE_REG=            \"JLE_REG\",\r\n    JLE_LIT=            \"JLE_LIT\",\r\n    JGE_REG=            \"JGE_REG\",\r\n    JGE_LIT=            \"JGE_LIT\",\r\n\r\n    PSH_LIT=            \"PSH_LIT\",\r\n    PSH_RS=             \"PSH_RS\",\r\n    POP=                \"POP\",\r\n    CAL_LIT=            \"CAL_LIT\",\r\n    CAL_RS=             \"CAL_RS\",\r\n    RET=                \"RET\",\r\n    HLT=                \"HLT\",\r\n    INT=                \"INT\",\r\n    RET_INT=            \"RET_INT\"\r\n};\r\n\r\n// Formatted for convenience in parsing\r\nexport const instructionType = {\r\n    [InstructionMnemonic.MOV]: {\r\n        regReg:     Instruction.MOV_RS_RD,\r\n        litReg:     Instruction.MOV_LIT_RD,\r\n        memReg:     Instruction.LDR_MEM_RD,\r\n        regMem:     Instruction.STR_RS_MEM,\r\n        litMem:     Instruction.STR_LIT_MEM,\r\n        regIndReg:   Instruction.LDR_REG_IND_REG,\r\n        litOffReg:   Instruction.LDR_LIT_OFF_REG,\r\n    },\r\n    [InstructionMnemonic.ADD]: {\r\n        regReg:  Instruction.ADD_RX_RY,\r\n        litReg:  Instruction.ADD_LIT_REG\r\n    },\r\n    [InstructionMnemonic.SUB]: {\r\n        regReg:  Instruction.SUB_RX_RY,\r\n        regLit:  Instruction.SUB_REG_LIT,\r\n        litReg:  Instruction.SUB_LIT_REG\r\n    },\r\n    [InstructionMnemonic.MUL]: {\r\n        regReg:  Instruction.MUL_REG_REG,\r\n        litReg:  Instruction.MUL_LIT_REG\r\n    },\r\n    [InstructionMnemonic.AND]: {\r\n        regReg:  Instruction.AND_REG_REG,\r\n        regLit:  Instruction.AND_REG_LIT\r\n    },\r\n    [InstructionMnemonic.OR]: {\r\n        regReg:  Instruction.OR_REG_REG,\r\n        regLit:  Instruction.OR_REG_LIT\r\n    },\r\n    [InstructionMnemonic.XOR]: {\r\n        regReg:  Instruction.XOR_REG_REG,\r\n        regLit:  Instruction.XOR_REG_LIT\r\n    },\r\n    [InstructionMnemonic.LSL]: {\r\n        regReg: Instruction.LSL_REG_REG,\r\n        regLit: Instruction.LSL_REG_LIT\r\n    },\r\n    [InstructionMnemonic.LSR]: {\r\n        regReg: Instruction.LSR_REG_REG,\r\n        regLit: Instruction.LSR_REG_LIT\r\n    },\r\n    [InstructionMnemonic.INC]: {\r\n        singleReg: Instruction.INC_REG\r\n    },\r\n    [InstructionMnemonic.DEC]: {\r\n        singleReg: Instruction.DEC_REG\r\n    },\r\n    [InstructionMnemonic.NOT]: {\r\n        singleReg: Instruction.NOT\r\n    },\r\n    [InstructionMnemonic.JEQ]: {\r\n        regMem: Instruction.JEQ_REG,\r\n        litMem: Instruction.JEQ_LIT\r\n    },\r\n    [InstructionMnemonic.JNE]: {\r\n        regMem: Instruction.JNE_REG,\r\n        litMem: Instruction.JMP_NOT_EQ\r\n    },\r\n    [InstructionMnemonic.JLT]: {\r\n        regMem: Instruction.JLT_REG,\r\n        litMem: Instruction.JLT_LIT\r\n    },\r\n    [InstructionMnemonic.JGT]: {\r\n        regMem: Instruction.JGT_REG,\r\n        litMem: Instruction.JGT_LIT\r\n    },\r\n    [InstructionMnemonic.JLE]: {\r\n        regMem: Instruction.JLE_REG,\r\n        litMem: Instruction.JLE_LIT\r\n    },\r\n    [InstructionMnemonic.JGE]: {\r\n        regMem: Instruction.JGE_REG,\r\n        litMem: Instruction.JGE_LIT\r\n    },\r\n    [InstructionMnemonic.PSH]: {\r\n        singleReg: Instruction.PSH_RS,\r\n        singleLit: Instruction.PSH_LIT\r\n    },\r\n    [InstructionMnemonic.POP]: {\r\n        singleReg: Instruction.POP\r\n    },\r\n    [InstructionMnemonic.CAL]: {\r\n        singleReg: Instruction.CAL_RS,\r\n        singleLit: Instruction.CAL_LIT\r\n    },\r\n    [InstructionMnemonic.RET]: {\r\n        noArgs: Instruction.RET\r\n    },\r\n    [InstructionMnemonic.HLT]: {\r\n        noArgs: Instruction.HLT\r\n    }\r\n} as const;\r\n\r\ntype InstructionMeta = {\r\n    [key in Instruction]: {\r\n        instruction: Instruction,\r\n        opCode: number,\r\n        type: InstructionTypes,\r\n        size: number,\r\n        mnemonic: InstructionMnemonic\r\n    }\r\n};\r\n\r\nconst getMeta = (instructionType: InstructionTypes) => ({\r\n    type: InstructionTypes[instructionType],\r\n    size: instructionSize[instructionType]\r\n});\r\n\r\n// Meta info corresponding to each instruction type (for parsing)\r\nconst instructionsMeta: InstructionMeta = {\r\n    [Instruction.MOV_LIT_RD]: {\r\n        instruction: Instruction.MOV_LIT_RD,\r\n        opCode: 0x10,\r\n        ...getMeta(InstructionTypes.litReg),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.MOV_RS_RD]: {\r\n        instruction: Instruction.MOV_RS_RD,\r\n        opCode: 0x11,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.STR_RS_MEM]: {\r\n        instruction: Instruction.STR_RS_MEM,\r\n        opCode: 0x12,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.LDR_MEM_RD]: {\r\n        instruction: Instruction.LDR_MEM_RD,\r\n        opCode: 0x13,\r\n        ...getMeta(InstructionTypes.memReg),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.STR_LIT_MEM]: {\r\n        instruction: Instruction.STR_LIT_MEM,\r\n        opCode: 0x1B,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.LDR_REG_IND_REG]: {\r\n        instruction: Instruction.LDR_REG_IND_REG,\r\n        opCode: 0x1C,\r\n        ...getMeta(InstructionTypes.regIndReg),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    [Instruction.LDR_LIT_OFF_REG]: {\r\n        instruction: Instruction.LDR_LIT_OFF_REG,\r\n        opCode: 0x1D,\r\n        ...getMeta(InstructionTypes.litOffReg),\r\n        mnemonic: InstructionMnemonic.MOV\r\n    },\r\n    \r\n    [Instruction.ADD_RX_RY]: {\r\n        instruction: Instruction.ADD_RX_RY,\r\n        opCode: 0x14,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.ADD\r\n    },\r\n    [Instruction.ADD_LIT_REG]: {\r\n        instruction: Instruction.ADD_LIT_REG,\r\n        opCode: 0x3F,\r\n        ...getMeta(InstructionTypes.litReg),\r\n        mnemonic: InstructionMnemonic.ADD\r\n    },\r\n    [Instruction.SUB_LIT_REG]: {\r\n        instruction: Instruction.SUB_LIT_REG,\r\n        opCode: 0x16,\r\n        ...getMeta(InstructionTypes.litReg),\r\n        mnemonic: InstructionMnemonic.SUB\r\n    },\r\n    [Instruction.SUB_REG_LIT]: {\r\n        instruction: Instruction.SUB_REG_LIT,\r\n        opCode: 0x1E,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.SUB\r\n    },\r\n    [Instruction.SUB_RX_RY]: {\r\n        instruction: Instruction.SUB_RX_RY,\r\n        opCode: 0x1F,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.SUB\r\n    },\r\n    [Instruction.INC_REG]: {\r\n        instruction: Instruction.INC_REG,\r\n        opCode: 0x35,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.INC\r\n    },\r\n    [Instruction.DEC_REG]: {\r\n        instruction: Instruction.DEC_REG,\r\n        opCode: 0x36,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.DEC\r\n    },\r\n    [Instruction.MUL_LIT_REG]: {\r\n        instruction: Instruction.MUL_LIT_REG,\r\n        opCode: 0x20,\r\n        ...getMeta(InstructionTypes.litReg),\r\n        mnemonic: InstructionMnemonic.MUL\r\n    },\r\n    [Instruction.MUL_REG_REG]: {\r\n        instruction: Instruction.MUL_REG_REG,\r\n        opCode: 0x21,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.MUL\r\n    },\r\n\r\n    [Instruction.LSL_REG_LIT]: {\r\n        instruction: Instruction.LSL_REG_LIT,\r\n        opCode: 0x26,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.LSL\r\n    },\r\n    [Instruction.LSL_REG_REG]: {\r\n        instruction: Instruction.LSL_REG_REG,\r\n        opCode: 0x27,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.LSL\r\n    },\r\n    [Instruction.LSR_REG_LIT]: {\r\n        instruction: Instruction.LSL_REG_LIT,\r\n        opCode: 0x2A,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.LSR\r\n    },\r\n    [Instruction.LSR_REG_REG]: {\r\n        instruction: Instruction.LSR_REG_REG,\r\n        opCode: 0x2B,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.LSR\r\n    },\r\n    [Instruction.AND_REG_LIT]: {\r\n        instruction: Instruction.AND_REG_LIT,\r\n        opCode: 0x2E,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.AND\r\n    },\r\n    [Instruction.AND_REG_REG]: {\r\n        instruction: Instruction.AND_REG_REG,\r\n        opCode: 0x2F,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.AND\r\n    },\r\n    [Instruction.OR_REG_LIT]: {\r\n        instruction: Instruction.OR_REG_LIT,\r\n        opCode: 0x30,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.OR\r\n    },\r\n    [Instruction.OR_REG_REG]: {\r\n        instruction: Instruction.OR_REG_REG,\r\n        opCode: 0x31,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.OR\r\n    },\r\n    [Instruction.XOR_REG_LIT]: {\r\n        instruction: Instruction.XOR_REG_LIT,\r\n        opCode: 0x32,\r\n        ...getMeta(InstructionTypes.regLit),\r\n        mnemonic: InstructionMnemonic.XOR\r\n    },\r\n    [Instruction.XOR_REG_REG]: {\r\n        instruction: Instruction.XOR_REG_REG,\r\n        opCode: 0x33,\r\n        ...getMeta(InstructionTypes.regReg),\r\n        mnemonic: InstructionMnemonic.XOR\r\n    },\r\n    [Instruction.NOT]: {\r\n        instruction: Instruction.NOT,\r\n        opCode: 0x34,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.NOT\r\n    },\r\n\r\n    [Instruction.JMP_NOT_EQ]: {\r\n        instruction: Instruction.JMP_NOT_EQ,\r\n        opCode: 0x15,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.JNE\r\n    },\r\n    [Instruction.JNE_REG]: {\r\n        instruction: Instruction.JNE_REG,\r\n        opCode: 0x40,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.JNE\r\n    },\r\n    [Instruction.JEQ_REG]: {\r\n        instruction: Instruction.JEQ_REG,\r\n        opCode: 0x3E,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.JEQ\r\n    },\r\n    [Instruction.JEQ_LIT]: {\r\n        instruction: Instruction.JEQ_LIT,\r\n        opCode: 0x41,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.JEQ\r\n    },\r\n    [Instruction.JLT_REG]: {\r\n        instruction: Instruction.JLT_REG,\r\n        opCode: 0x42,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.MUL\r\n    },\r\n    [Instruction.JLT_LIT]: {\r\n        instruction: Instruction.JLT_LIT,\r\n        opCode: 0x43,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.MUL\r\n    },\r\n    [Instruction.JGT_REG]: {\r\n        instruction: Instruction.JGT_REG,\r\n        opCode: 0x44,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.JGT\r\n    },\r\n    [Instruction.JGT_LIT]: {\r\n        instruction: Instruction.JGT_LIT,\r\n        opCode: 0x45,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.JGT\r\n    },\r\n    [Instruction.JLE_REG]: {\r\n        instruction: Instruction.JLE_REG,\r\n        opCode: 0x46,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.JLE\r\n    },\r\n    [Instruction.JLE_LIT]: {\r\n        instruction: Instruction.JLE_LIT,\r\n        opCode: 0x47,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.JLE\r\n    },\r\n    [Instruction.JGE_REG]: {\r\n        instruction: Instruction.JGE_REG,\r\n        opCode: 0x48,\r\n        ...getMeta(InstructionTypes.regMem),\r\n        mnemonic: InstructionMnemonic.JGE\r\n    },\r\n    [Instruction.JGE_LIT]: {\r\n        instruction: Instruction.JGE_LIT,\r\n        opCode: 0x49,\r\n        ...getMeta(InstructionTypes.litMem),\r\n        mnemonic: InstructionMnemonic.JGE\r\n    },\r\n\r\n    [Instruction.PSH_LIT]: {\r\n        instruction: Instruction.PSH_LIT,\r\n        opCode: 0x17,\r\n        ...getMeta(InstructionTypes.singleLit),\r\n        mnemonic: InstructionMnemonic.PSH\r\n    },\r\n    [Instruction.PSH_RS]: {\r\n        instruction: Instruction.PSH_RS,\r\n        opCode: 0x18,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.PSH\r\n    },\r\n    [Instruction.POP]: {\r\n        instruction: Instruction.POP,\r\n        opCode: 0x1A,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.POP\r\n    },\r\n    [Instruction.CAL_LIT]: {\r\n        instruction: Instruction.CAL_LIT,\r\n        opCode: 0x5E,\r\n        ...getMeta(InstructionTypes.singleLit),\r\n        mnemonic: InstructionMnemonic.CAL\r\n    },\r\n    [Instruction.CAL_RS]: {\r\n        instruction: Instruction.CAL_RS,\r\n        opCode: 0x5F,\r\n        ...getMeta(InstructionTypes.singleReg),\r\n        mnemonic: InstructionMnemonic.CAL\r\n    },\r\n    [Instruction.RET]: {\r\n        instruction: Instruction.RET,\r\n        opCode: 0x60,\r\n        ...getMeta(InstructionTypes.noArgs),\r\n        mnemonic: InstructionMnemonic.RET\r\n    },\r\n    [Instruction.HLT]: {\r\n        instruction: Instruction.HLT,\r\n        opCode: 0xFF,\r\n        ...getMeta(InstructionTypes.noArgs),\r\n        mnemonic: InstructionMnemonic.HLT\r\n    },\r\n    [Instruction.INT]: {\r\n        instruction: Instruction.INT,\r\n        opCode: 0xFD,\r\n        ...getMeta(InstructionTypes.singleLit),\r\n        mnemonic: InstructionMnemonic.INT\r\n    },\r\n    [Instruction.RET_INT]: {\r\n        instruction: Instruction.RET_INT,\r\n        opCode: 0xFC,\r\n        ...getMeta(InstructionTypes.noArgs),\r\n        mnemonic: InstructionMnemonic.RET_INT\r\n    }\r\n}\r\n\r\nexport default instructionsMeta;\r\n","// Supported general purpose registers\r\nexport default [\r\n    'r0', 'r1', 'r2', 'r3',\r\n    'r4', 'r5', 'r6', 'r7',\r\n    'acc', 'mb', 'im', 'sp', 'fp', 'pc'\r\n] as const;\r\n","import { createMemory } from './createMemory';\r\nimport type { IMemory, Memory } from '../types';\r\nimport instructions from './instructions';\r\nimport instructionsMeta from './instructions';\r\nimport registers from './registers';\r\n\r\ntype RegisterBank = any;\r\n\r\n/**\r\n * The Processor\r\n */\r\nclass CPU {\r\n    #memory: IMemory;                           // Main memory [8-bit words]\r\n    readonly #registerLabels: string[];         // Names for general purpose 16-bit registers (GPRs).\r\n    #registers: Memory;                         // Memory for the GPRs.\r\n    #registersMap: Object;                      // Map: Register Label -> Memory Location \r\n    #stackFrameSize: number;                    // Size of the current stack frame.\r\n    #interruptVectorAddress: number;\r\n    #isInInterruptHandler: boolean;\r\n\r\n    /**\r\n     * Create a new CPU with the specified main memory.\r\n     * @param memory Memory, this CPU's main memory module.\r\n     */\r\n    constructor(memory: IMemory, interruptVectorAddress = 0x1000) {\r\n        this.#memory = memory;\r\n\r\n        /** Register labels\r\n         *  'pc' -> program counter\r\n         *  'fp' -> frame pointer\r\n         *  'sp' -> stack pointer\r\n         *  'acc' -> arithmetic accumulator\r\n         *  'rx' -> general register\r\n         **/\r\n        this.#registerLabels = [...registers];\r\n\r\n        // 16-bits or 2 bytes for each register\r\n        this.#registers = createMemory(this.#registerLabels.length * 2);\r\n\r\n        // Map register label to its start bit in register memory.\r\n        this.#registersMap = this.#registerLabels.reduce((map, label, idx) => {\r\n            map[label]  = idx * 2;\r\n            return map;\r\n        }, {});\r\n\r\n        this.#stackFrameSize = 0;\r\n\r\n        // Up to 16 interrupt handlers\r\n        this.#interruptVectorAddress = interruptVectorAddress;\r\n        this.#isInInterruptHandler = false;\r\n        // Enable all interrupts\r\n        this.setRegister('im', 0xffff);\r\n\r\n        /* Set stack and frame pointer to end of mmem. */\r\n\r\n        // -2 since 0-index and 16-bit instructions: 2 bytes\r\n        // notice that the implementation decrements *after* insertion.\r\n        this.setRegister('sp', 0xffff - 1);  // Storing 2 bytes, start at block [0xfffe, 0xffff]\r\n        this.setRegister('fp', 0xffff - 1);\r\n    }\r\n\r\n    /**\r\n     * Prints the name and contents of each register.\r\n     */\r\n    debug(): void {\r\n        this.#registerLabels.forEach((label: string): void => {\r\n            console.log(`${label}: \\t0x${this.getRegister(label).toString(16).padStart(4, '0')}`);\r\n        });\r\n        console.log('\\n----------\\n')\r\n    }\r\n\r\n    /**\r\n     * Prints the name and contents of each register.\r\n     */\r\n     getRegisterBank(): RegisterBank {\r\n        return this.#registerLabels.reduce((bank: RegisterBank, label: string, idx): void => {\r\n            bank[label] = `0x${this.getRegister(label).toString(16).padStart(4, '0')}`;\r\n            return bank;\r\n        }, {});\r\n    }\r\n\r\n    /**\r\n     * View the byte at the specified address in main memory\r\n     * in addition to the n bytes that follow.\r\n     * 0x0f01: 0x04 0xab 0x7f ... 0x08 [8 words here]\r\n     * @param address number, the address to inspect.\r\n     * @param n number, the number of bytes around address.\r\n     */\r\n    viewMemoryAt(address: number, n: number, print: boolean = true): number {\r\n        // Arraylike: [undefined x n].\r\n        // Get and format next n words starting with memory[address].\r\n        const nextNBytes = Array.from({length: n}, (_, i) =>\r\n            this.#memory.getUint8(address + i)\r\n        ).map(byte => `0x${byte.toString(16).padStart(2, '0')}`);\r\n\r\n        // Print the memory address followed by contents in 8 words.\r\n        if (print) console.log(`0x${address.toString(16).padStart(4, '0')}: ${nextNBytes.join(' ')}`);\r\n        return this.#memory.getUint16(address);\r\n    }\r\n\r\n   /**\r\n    * Get an unsigned representation for the 16 bits in register 'label'.\r\n    * @param label string, the label of the register.\r\n    * @returns number, the representation of the 16 bits in the register. \r\n    */\r\n    getRegister(label: string): number {\r\n        if (!(label in this.#registersMap)) \r\n            throw new Error (`getRegister(label): No such register '${label}'`);\r\n        return this.#registers.getUint16(this.#registersMap[label]);\r\n    }\r\n\r\n    /**\r\n     * Set the 16 bits in register 'label' with unsigned rep. of specified value.\r\n     * @param label string, the label of the register.\r\n     * @param value number, the unsigned 16 bit number to set.\r\n     */\r\n    setRegister(label: string, value: number): void {\r\n        if (!(label in this.#registersMap)) \r\n            throw new Error (`setRegister(label): No such register '${label}'`);\r\n        return this.#registers.setUint16(this.#registersMap[label], value);\r\n    }\r\n\r\n    /**\r\n     * CPU fetch cycle.\r\n     * Fetch next instruction from main memory and increment PC.\r\n     * @returns number, the 8-bit instruction.\r\n     */\r\n    fetch(): number {\r\n        const nextInstructionAddress = this.getRegister('pc');\r\n        const instruction = this.#memory.getUint8(nextInstructionAddress);\r\n        this.setRegister('pc', nextInstructionAddress + 1);                 // Incr 1 byte.\r\n        return instruction;\r\n    };\r\n\r\n    /**\r\n     * Get the contents of the next two 8-bit words (for 16-bit literals).\r\n     * This is not realistic.\r\n     * @returns number, the 16-bits for next two words\r\n     */\r\n    fetch16(): number {\r\n        const nextLiteralsAddress = this.getRegister('pc');\r\n        const literals = this.#memory.getUint16(nextLiteralsAddress);\r\n        this.setRegister('pc', nextLiteralsAddress + 2);                 // Incr 2 bytes.\r\n        return literals;\r\n    };\r\n\r\n    /**\r\n     * Get the register index from hex encoding in memory.\r\n     * Given 0x01 -> R1 -> index 2 (2nd set of bytes following R0).\r\n     * @returns number, the register index.\r\n     */\r\n    fetchRegIndex(): number { return (this.fetch() % this.#registerLabels.length) * 2; }\r\n\r\n    /**\r\n     * Push specified value to top of stack, then grow stack pointer (down).\r\n     * @param value number, the value to push to stack.\r\n     */\r\n    push(value: number): void {\r\n        const spAddress = this.getRegister('sp');\r\n        this.#memory.setUint16(spAddress, value);\r\n        this.setRegister('sp', spAddress - 2); // Stack grows down 2 bytes 16b.\r\n        this.#stackFrameSize += 2;\r\n    }\r\n\r\n    /**\r\n     * Pop top stack contents.\r\n     * @returns number, the popped contents.\r\n     */\r\n    pop(): number {\r\n        const spAddressPopped = this.getRegister('sp') + 2;\r\n        this.setRegister('sp', spAddressPopped);\r\n        this.#stackFrameSize -= 2;\r\n        return this.#memory.getUint16(spAddressPopped);\r\n    }\r\n\r\n    /**\r\n     * Push the current cpu state to the stack.\r\n     */\r\n    pushState(): void {\r\n        // Push contents of GPRs and PC to stack\r\n        this.#registerLabels.forEach((label: string) => {\r\n            if (['acc', 'sp', 'fp'].includes(label)) return;\r\n            this.push(this.getRegister(label));                    \r\n        })\r\n\r\n        this.push(this.#stackFrameSize + 2);    // Account for this push.\r\n        // Frame pointer updated to new stack frame.\r\n        this.setRegister('fp', this.getRegister('sp'));\r\n        this.#stackFrameSize = 0;\r\n    }\r\n\r\n    /**\r\n     * Pops the previous state off the \r\n     * stack corresponding to the frame pointer.\r\n     */\r\n    popState(): void {\r\n        const framePointerAddress = this.getRegister('fp');\r\n        // Right above stack frame size.\r\n        this.setRegister('sp', framePointerAddress);\r\n        this.#stackFrameSize = this.pop();\r\n        const stackFrameSize = this.#stackFrameSize;\r\n\r\n        // Pop PC then GPRs back.\r\n        this.#registerLabels.slice().reverse().forEach((label: string) => {\r\n            if (['acc', 'sp', 'fp'].includes(label)) return;\r\n            \r\n            this.setRegister(label, this.pop());                    \r\n        })\r\n\r\n        // Subroutine called with args, numberArgs.\r\n        const numberArgs = this.pop();\r\n        this.setRegister('sp', this.getRegister('sp') + numberArgs * 2);\r\n\r\n        // Reset to the previous frame.\r\n        this.setRegister('fp', framePointerAddress + stackFrameSize);\r\n    }\r\n\r\n    /**\r\n     * Executes the interrupts service routine\r\n     * corresponding to the specified id.\r\n     * @param id, id of the IRQ handler.\r\n     */\r\n    handleInterrupt(id: number) {\r\n        const interruptVectorIndex = id % 0xf;\r\n\r\n        // Check if interrupt is enabled.\r\n        const isUnmasked = Boolean((1 << interruptVectorIndex) & this.getRegister('im'));\r\n        if (!isUnmasked) { return; }\r\n\r\n        // Account for indexing by byte (counter is a nibble)\r\n        const handlerAddressPointer = this.#interruptVectorAddress + (interruptVectorIndex * 2);\r\n        const handlerAddress = this.#memory.getUint16(handlerAddressPointer);\r\n\r\n        // Don't push state if nested interrupts\r\n        if (!this.#isInInterruptHandler) {\r\n            this.push(0); // No arguments are passed to handlers\r\n            this.pushState();\r\n        }\r\n\r\n        this.#isInInterruptHandler = true;\r\n        this.setRegister('pc', handlerAddress);\r\n    }\r\n\r\n    /**\r\n     * Decode and execute the specified 8-bit instruction.\r\n     * @param instruction number, the 8-bit instruction to execute.\r\n     */\r\n    execute(instruction: number): boolean | void {\r\n        switch(instruction) {\r\n            // Move 16b literal into destination register.\r\n            case instructionsMeta.MOV_LIT_RD.opCode: {\r\n                // Get the index and account for byte offset: each Reg is 2 bytes.\r\n                const literal = this.fetch16();\r\n                const registerIdx = this.fetchRegIndex();\r\n                return this.#registers.setUint16(registerIdx, literal);\r\n            }\r\n\r\n            // Move source register contents to destination register.\r\n            case instructionsMeta.MOV_RS_RD.opCode: {\r\n                // Get register indices\r\n                const registerSrc = this.fetchRegIndex();\r\n                const registerDest = this.fetchRegIndex();\r\n                const srcVal = this.#registers.getUint16(registerSrc);\r\n                return this.#registers.setUint16(registerDest, srcVal);\r\n            }\r\n\r\n            // Store contents of source register into main memory[imm16].\r\n            case instructionsMeta.STR_RS_MEM.opCode: {\r\n                // Get register index\r\n                const registerSrc = this.fetchRegIndex();\r\n                const memAddress = this.fetch16();\r\n                const value = this.#registers.getUint16(registerSrc);\r\n                return this.#memory.setUint16(memAddress, value);\r\n            }\r\n\r\n            case instructionsMeta.STR_LIT_MEM.opCode: {\r\n                const value  = this.fetch16();\r\n                const memAddress = this.fetch16();\r\n                return this.#memory.setUint16(memAddress, value);\r\n            }\r\n\r\n            // Load contents of main memory[imm16] in destination register.\r\n            case instructionsMeta.LDR_MEM_RD.opCode: {\r\n                // Get register index\r\n                const memAddress = this.fetch16();\r\n                const registerSrc = this.fetchRegIndex();\r\n                const value = this.#memory.getUint16(memAddress);\r\n                return this.#registers.setUint16(registerSrc, value);\r\n            }\r\n\r\n            // [R2] <- Mmem[R1]\r\n            case instructionsMeta.LDR_REG_IND_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const ptr = this.#registers.getUint16(r1);\r\n                const value = this.#memory.getUint16(ptr);\r\n                this.#registers.setUint16(r2, value);\r\n            }\r\n\r\n            // [RD] <- Mmem[RS + offset] *Unsigned offset\r\n            case instructionsMeta.LDR_LIT_OFF_REG.opCode: {\r\n                const baseAddress = this.fetch16(); // Offset\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const offset = this.#registers.getUint16(r1);\r\n                const value = this.#memory.getUint16(baseAddress + offset);\r\n                return this.#registers.setUint16(r2, value);\r\n            }\r\n\r\n            // Add register x to register y.\r\n            case instructionsMeta.ADD_RX_RY.opCode: {\r\n                // 8bit : [0 -> 7], No Instruction Register here\r\n                const rx = this.fetchRegIndex();\r\n                const ry = this.fetchRegIndex();\r\n                const registerValueX = this.#registers.getUint16(rx);\r\n                const registerValueY = this.#registers.getUint16(ry);\r\n                return this.setRegister('acc', registerValueX + registerValueY);\r\n            }\r\n\r\n            case instructionsMeta.ADD_LIT_REG.opCode: {\r\n                const literal = this.fetch16();\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue + literal);\r\n            }\r\n\r\n            //* unsigned register - literal\r\n            case instructionsMeta.SUB_LIT_REG.opCode: {\r\n                const literal = this.fetch16();\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue - literal);\r\n            }\r\n\r\n            //* unsigned literal - register\r\n            case instructionsMeta.SUB_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const lit = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', lit - registerValue);\r\n            }\r\n\r\n            case instructionsMeta.SUB_RX_RY.opCode: {\r\n                const rx = this.fetchRegIndex();\r\n                const ry = this.fetchRegIndex();\r\n                const registerValueX = this.#registers.getUint16(rx);\r\n                const registerValueY = this.#registers.getUint16(ry);\r\n                return this.setRegister('acc', registerValueX - registerValueY);\r\n            }\r\n\r\n            case instructionsMeta.MUL_LIT_REG.opCode: {\r\n                const literal = this.fetch16();\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue * literal);\r\n            }\r\n\r\n            // * unsigned\r\n            case instructionsMeta.MUL_REG_REG.opCode: {\r\n                const rx = this.fetchRegIndex();\r\n                const ry = this.fetchRegIndex();\r\n                const registerValueX = this.#registers.getUint16(rx);\r\n                const registerValueY = this.#registers.getUint16(ry);\r\n                return this.setRegister('acc', registerValueX * registerValueY);\r\n            }\r\n\r\n            case instructionsMeta.INC_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.#registers.setUint16(r1, registerValue + 1);\r\n            }\r\n\r\n            case instructionsMeta.DEC_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.#registers.setUint16(r1, registerValue - 1);\r\n            }\r\n\r\n            // in place\r\n            case instructionsMeta.LSL_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const literal = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.#registers.setUint16(r1, registerValue << literal);\r\n            }\r\n\r\n            case instructionsMeta.LSL_REG_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const register1Value = this.#registers.getUint16(r1);\r\n                const register2Value = this.#registers.getUint16(r2);\r\n                return this.#registers.setUint16(r1, register1Value << register2Value);\r\n            }\r\n\r\n            case instructionsMeta.LSR_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const literal = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.#registers.setUint16(r1, registerValue >> literal);\r\n            }\r\n\r\n            case instructionsMeta.LSR_REG_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const register1Value = this.#registers.getUint16(r1);\r\n                const register2Value = this.#registers.getUint16(r2);\r\n                return this.#registers.setUint16(r1, register1Value >> register2Value);\r\n            }\r\n\r\n            case instructionsMeta.AND_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const literal = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue & literal);\r\n            }\r\n\r\n            case instructionsMeta.AND_REG_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const register1Value = this.#registers.getUint16(r1);\r\n                const register2Value = this.#registers.getUint16(r2);\r\n                return this.setRegister('acc', register1Value & register2Value);\r\n            }\r\n\r\n            case instructionsMeta.OR_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const literal = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue | literal);\r\n            }\r\n\r\n            case instructionsMeta.OR_REG_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const register1Value = this.#registers.getUint16(r1);\r\n                const register2Value = this.#registers.getUint16(r2);\r\n                return this.setRegister('acc', register1Value | register2Value);\r\n            }\r\n\r\n            case instructionsMeta.XOR_REG_LIT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const literal = this.fetch16();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n                return this.setRegister('acc', registerValue ^ literal);\r\n            }\r\n\r\n            case instructionsMeta.XOR_REG_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const r2 = this.fetchRegIndex();\r\n                const register1Value = this.#registers.getUint16(r1);\r\n                const register2Value = this.#registers.getUint16(r2);\r\n                return this.setRegister('acc', register1Value ^ register2Value);\r\n            }\r\n\r\n            case instructionsMeta.NOT.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const registerValue = this.#registers.getUint16(r1);\r\n\r\n                // JS internally converts the value to 32 bits, with 1s\r\n                // in MSB 16 bits -> mask to get the LSB 16 which we want;\r\n                const invertedValue = (~registerValue) & 0xffff\r\n                return this.setRegister('acc', invertedValue);\r\n            }\r\n\r\n            // Branch to specified address iff literal != [acc]\r\n            case instructionsMeta.JMP_NOT_EQ.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal !== this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JNE_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value !== this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JEQ_LIT.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal === this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JEQ_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value === this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JLT_LIT.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal < this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JLT_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value < this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JGT_LIT.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal > this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JGT_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value > this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JLE_LIT.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal <= this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JLE_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value <= this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JGE_LIT.opCode: {\r\n                const literal = this.fetch16();\r\n                const branchAddress = this.fetch16();\r\n                if (literal >= this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            case instructionsMeta.JGE_REG.opCode: {\r\n                const r1 = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(r1);\r\n                const branchAddress = this.fetch16();\r\n                if (value >= this.getRegister('acc'))\r\n                    this.setRegister('pc', branchAddress);\r\n                return;\r\n            }\r\n\r\n            // Push a literal to top of stack.\r\n            case instructionsMeta.PSH_LIT.opCode: {\r\n                const value = this.fetch16();\r\n                return this.push(value);\r\n            }\r\n\r\n            // Push the contents of source register to top of stack.\r\n            case instructionsMeta.PSH_RS.opCode: {\r\n                const registerSrc = this.fetchRegIndex();\r\n                const value = this.#registers.getUint16(registerSrc);\r\n                return this.push(value);\r\n            }\r\n            \r\n            // Pop contents at top of stack in destination register.\r\n            case instructionsMeta.POP.opCode: {\r\n                const registerDest = this.fetchRegIndex();\r\n                return this.#registers.setUint16(registerDest, this.pop());\r\n            }\r\n\r\n            // Branch to subroutine at literal address\r\n            case instructionsMeta.CAL_LIT.opCode: {\r\n                const branchAddress = this.fetch16();\r\n                this.pushState();\r\n                // Branch to subroutine\r\n                return this.setRegister('pc', branchAddress);\r\n            }\r\n\r\n             // Branch to subroutine at address in register\r\n             case instructionsMeta.CAL_RS.opCode: {\r\n                const registerIdx = this.fetchRegIndex();\r\n                const branchAddress = this.#registers.getUint16(registerIdx);\r\n                this.pushState();\r\n                // Branch to subroutine\r\n                return this.setRegister('pc', branchAddress);\r\n            }\r\n\r\n            // Return from subroutine\r\n            case instructionsMeta.RET.opCode: {\r\n                return this.popState();\r\n           }\r\n\r\n           case instructionsMeta.HLT.opCode: {\r\n               return true;\r\n           }\r\n\r\n           case instructionsMeta.INT.opCode: {\r\n               const interruptID = this.fetch16();\r\n               return this.handleInterrupt(interruptID);\r\n           }\r\n\r\n           case instructionsMeta.RET_INT.opCode: {\r\n               this.#isInInterruptHandler = false;\r\n               this.popState();\r\n           }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform a fetch, decode, execute CPU cycle [usually 4 words - opCode, rx, ry, mem]\r\n     */\r\n    cycle(): boolean | void { return this.execute(this.fetch()); }\r\n\r\n    run() {\r\n        const halt = this.cycle();\r\n\r\n        if(!halt) {\r\n            setImmediate(() => this.run());\r\n        }\r\n    }\r\n}\r\n\r\nexport default CPU;","import type { Memory } from '../types';\r\n\r\n// Creates a main memory buffer\r\nexport const createMemory = (bytes: number): Memory => {\r\n    // Memory => typed array of bytes : interpret as signed or unsigned.\r\n    const ab = new ArrayBuffer(bytes);\r\n    const dv = new DataView(ab);        // Indexed by bytes!\r\n    return dv;\r\n};\r\n"],"sourceRoot":""}